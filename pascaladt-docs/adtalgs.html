<html>
<head>
<title></title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
<meta name="generator" content="SrcDoc 0.1">
<link rel="stylesheet" type="text/css" href="default.css">
</head>
<body>
<p>

<h1>adtalgs</h1>

<h3>Uses in interface</h3>
<a href="adtfunct.html">adtfunct</a>, <a href="adtcontbase.html">adtcontbase</a>, <a href="adtcont.html">adtcont</a>, <a href="adtiters.html">adtiters</a>
</p><p>

<h3>Description</h3>
 This unit provides various algorithms to be used with the PascalAdt containers. There are also several iterator classes useful in connection with the algorithms. The algorithms are grouped into four main sets: non-modifying, modifying, mutating, sorted-range, set algorithms and container algorithms. If the iterators which are the arguments of a given routine are indicated const, then it means that the range is not modified in any way and neither are the items themselves. The same applies to containers, i.e. if they are indicated const they are not changed in any way, if not they may be changed.
</p><p>
 In most cases when an algorithm routine takes a comparer parameter a nil value may be passed to use a default one instead. This, however, works only for types for which such a default comparer may be reasonably specified, i.e. Integer, Cardinal, Real and String. With any other type the use of nil for a comparer parameter will most probably result in a segmentation fault..
<h2>Declarations</h2>

</p>
<table cols="4" border="1" width="100%">
<tr>
<td width="30%">
<p>

<h4>Name</h4>

</p>
</td>
<td width="15%">
<p>

<h4>Type</h4>

</p>
</td>
<td width="15%">
<p>

<h4>Visibility</h4>

</p>
</td>
<td width="40%">
<p>

<h4>Synopsis</h4>

</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs__-TInserter.html">TInserter</a>
</p>
</td>
<td width="15%">
<p>
class
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Inserts items into a sequence before a given forward iterator.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs__-TInserterBase.html">TInserterBase</a>
</p>
</td>
<td width="15%">
<p>
class
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 A base class for inserter iterators.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs__-TBasicInserter.html">TBasicInserter</a>
</p>
</td>
<td width="15%">
<p>
class
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 An output iterator writing into a container using the general InsertItem method.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs__-TBackInserter.html">TBackInserter</a>
</p>
</td>
<td width="15%">
<p>
class
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 An output iterator inserting at the back of a queue.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs__-TFrontInserter.html">TFrontInserter</a>
</p>
</td>
<td width="15%">
<p>
class
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 An output iterator inserting at the front of a deque.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs__-TStringInserter.html">TStringInserter</a>
</p>
</td>
<td width="15%">
<p>
class
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Inserts items into a sequence before a given forward iterator.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs__-TStringInserterBase.html">TStringInserterBase</a>
</p>
</td>
<td width="15%">
<p>
class
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 A base class for inserter iterators.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs__-TStringBasicInserter.html">TStringBasicInserter</a>
</p>
</td>
<td width="15%">
<p>
class
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 An output iterator writing into a container using the general InsertItem method.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs__-TStringBackInserter.html">TStringBackInserter</a>
</p>
</td>
<td width="15%">
<p>
class
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 An output iterator inserting at the back of a queue.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs__-TStringFrontInserter.html">TStringFrontInserter</a>
</p>
</td>
<td width="15%">
<p>
class
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 An output iterator inserting at the front of a deque.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs__-TIntegerInserter.html">TIntegerInserter</a>
</p>
</td>
<td width="15%">
<p>
class
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Inserts items into a sequence before a given forward iterator.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs__-TIntegerInserterBase.html">TIntegerInserterBase</a>
</p>
</td>
<td width="15%">
<p>
class
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 A base class for inserter iterators.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs__-TIntegerBasicInserter.html">TIntegerBasicInserter</a>
</p>
</td>
<td width="15%">
<p>
class
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 An output iterator writing into a container using the general InsertItem method.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs__-TIntegerBackInserter.html">TIntegerBackInserter</a>
</p>
</td>
<td width="15%">
<p>
class
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 An output iterator inserting at the back of a queue.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs__-TIntegerFrontInserter.html">TIntegerFrontInserter</a>
</p>
</td>
<td width="15%">
<p>
class
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 An output iterator inserting at the front of a deque.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#Find">Find</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Non-modifying algorithms do not change anything in the ranges they are applied to.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#Find___overloaded___0">Find</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 The same as above, but uses pred to test which item to return.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#Count">Count</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Returns the number of items satisfying the predicate pred.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#Minimal">Minimal</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Returns an iterator pointing to the first minimal item in the range [start,finish).
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#Maximal">Maximal</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Returns an iterator pointing to the first maximal item in the range [start,finish).
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#Equal">Equal</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Returns true if two ranges are item-to-item equal.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#Mismatch">Mismatch</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Returns the first pair of iterators such that Result.First is an iterator into the first range, Result.Second into the second, and First &lt;&gt; Second.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#LexicographicalCompare">LexicographicalCompare</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Compares two ranges lexicographically.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#Partition">Partition</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Partitions [start,finish) according to pred.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#Partition___overloaded___0">Partition</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Partitions [start,finish) according to pred.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#StablePartition">StablePartition</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 The same as the ordinary Partition, but stable.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#MemoryEfficientStablePartition">MemoryEfficientStablePartition</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 The smae as StablePartition, but better memory usage, though worse running time.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#FindKthItem">FindKthItem</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Returns the k-th item in the range [start,finish) according to comparer.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#FindKthItemHoare">FindKthItemHoare</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Implements the Hoare's algorithm for finding the k-th element.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#Delete">Delete</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Deleting algorithms do not modify any items or their order, but may remove some from the container.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#DeleteIf">DeleteIf</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Deletes all items in the range [start,start+n) for which pred returns true.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#BinaryFind">BinaryFind</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 These algorithms may be used only with sorted ranges.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#InterpolationFind">InterpolationFind</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Performs an interpolation search.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#Unique">Unique</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Deletes duplicated items from the range [start,start+n).
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#SetUnion">SetUnion</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Set algorithms operate on whole containers, which are sets.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#SetUnionCopy">SetUnionCopy</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 The same as above, but copies the items and does not modify the containers.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#SetUnionCopyToArg">SetUnionCopyToArg</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 The same as above but does not create a new set but copies the items to set1 instead..
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#SetIntersection">SetIntersection</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Returns the intersection of <span class="local_symbol">set1</span> and <span class="local_symbol">set2</span>.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#SetIntersectionCopy">SetIntersectionCopy</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Returns the intersection of <span class="local_symbol">set1</span> and <span class="local_symbol">set2</span>.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#SetDifferenceCopy">SetDifferenceCopy</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Returns <span class="local_symbol">set1</span> \ <span class="local_symbol">set2</span>.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#SetSymmetricDifferenceCopy">SetSymmetricDifferenceCopy</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Returns the symmetric difference of <span class="local_symbol">set1</span> and <span class="local_symbol">set2</span>.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#Find___overloaded___1">Find</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Non-modifying algorithms do not change anything in the ranges they are applied to.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#Find___overloaded___2">Find</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 The same as above, but uses pred to test which item to return.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#Count___overloaded___0">Count</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Returns the number of items satisfying the predicate pred.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#Minimal___overloaded___0">Minimal</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Returns an iterator pointing to the first minimal item in the range [start,finish).
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#Maximal___overloaded___0">Maximal</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Returns an iterator pointing to the first maximal item in the range [start,finish).
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#Equal___overloaded___0">Equal</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Returns true if two ranges are item-to-item equal.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#Mismatch___overloaded___0">Mismatch</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Returns the first pair of iterators such that Result.First is an iterator into the first range, Result.Second into the second, and First &lt;&gt; Second.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#LexicographicalCompare___overloaded___0">LexicographicalCompare</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Compares two ranges lexicographically.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#Partition___overloaded___1">Partition</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Partitions [start,finish) according to pred.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#Partition___overloaded___2">Partition</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Partitions [start,finish) according to pred.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#StablePartition___overloaded___0">StablePartition</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 The same as the ordinary Partition, but stable.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#MemoryEfficientStablePartition___overloaded___0">MemoryEfficientStablePartition</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 The smae as StablePartition, but better memory usage, though worse running time.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#FindKthItem___overloaded___0">FindKthItem</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Returns the k-th item in the range [start,finish) according to comparer.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#FindKthItemHoare___overloaded___0">FindKthItemHoare</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Implements the Hoare's algorithm for finding the k-th element.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#Delete___overloaded___0">Delete</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Deleting algorithms do not modify any items or their order, but may remove some from the container.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#DeleteIf___overloaded___0">DeleteIf</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Deletes all items in the range [start,start+n) for which pred returns true.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#BinaryFind___overloaded___0">BinaryFind</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 These algorithms may be used only with sorted ranges.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#InterpolationFind___overloaded___0">InterpolationFind</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Performs an interpolation search.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#Unique___overloaded___0">Unique</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Deletes duplicated items from the range [start,start+n).
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#SetUnion___overloaded___0">SetUnion</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Set algorithms operate on whole containers, which are sets.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#SetUnionCopy___overloaded___0">SetUnionCopy</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 The same as above, but copies the items and does not modify the containers.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#SetUnionCopyToArg___overloaded___0">SetUnionCopyToArg</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 The same as above but does not create a new set but copies the items to set1 instead..
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#SetIntersection___overloaded___0">SetIntersection</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Returns the intersection of <span class="local_symbol">set1</span> and <span class="local_symbol">set2</span>.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#SetIntersectionCopy___overloaded___0">SetIntersectionCopy</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Returns the intersection of <span class="local_symbol">set1</span> and <span class="local_symbol">set2</span>.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#SetDifferenceCopy___overloaded___0">SetDifferenceCopy</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Returns <span class="local_symbol">set1</span> \ <span class="local_symbol">set2</span>.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#SetSymmetricDifferenceCopy___overloaded___0">SetSymmetricDifferenceCopy</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Returns the symmetric difference of <span class="local_symbol">set1</span> and <span class="local_symbol">set2</span>.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#Find___overloaded___3">Find</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Non-modifying algorithms do not change anything in the ranges they are applied to.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#Find___overloaded___4">Find</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 The same as above, but uses pred to test which item to return.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#Count___overloaded___1">Count</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Returns the number of items satisfying the predicate pred.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#Minimal___overloaded___1">Minimal</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Returns an iterator pointing to the first minimal item in the range [start,finish).
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#Maximal___overloaded___1">Maximal</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Returns an iterator pointing to the first maximal item in the range [start,finish).
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#Equal___overloaded___1">Equal</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Returns true if two ranges are item-to-item equal.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#Mismatch___overloaded___1">Mismatch</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Returns the first pair of iterators such that Result.First is an iterator into the first range, Result.Second into the second, and First &lt;&gt; Second.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#LexicographicalCompare___overloaded___1">LexicographicalCompare</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Compares two ranges lexicographically.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#Partition___overloaded___3">Partition</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Partitions [start,finish) according to pred.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#Partition___overloaded___4">Partition</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Partitions [start,finish) according to pred.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#StablePartition___overloaded___1">StablePartition</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 The same as the ordinary Partition, but stable.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#MemoryEfficientStablePartition___overloaded___1">MemoryEfficientStablePartition</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 The smae as StablePartition, but better memory usage, though worse running time.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#FindKthItem___overloaded___1">FindKthItem</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Returns the k-th item in the range [start,finish) according to comparer.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#FindKthItemHoare___overloaded___1">FindKthItemHoare</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Implements the Hoare's algorithm for finding the k-th element.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#Delete___overloaded___1">Delete</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Deleting algorithms do not modify any items or their order, but may remove some from the container.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#DeleteIf___overloaded___1">DeleteIf</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Deletes all items in the range [start,start+n) for which pred returns true.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#BinaryFind___overloaded___1">BinaryFind</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 These algorithms may be used only with sorted ranges.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#InterpolationFind___overloaded___1">InterpolationFind</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Performs an interpolation search.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#Unique___overloaded___1">Unique</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Deletes duplicated items from the range [start,start+n).
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#SetUnion___overloaded___1">SetUnion</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Set algorithms operate on whole containers, which are sets.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#SetUnionCopy___overloaded___1">SetUnionCopy</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 The same as above, but copies the items and does not modify the containers.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#SetUnionCopyToArg___overloaded___1">SetUnionCopyToArg</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 The same as above but does not create a new set but copies the items to set1 instead..
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#SetIntersection___overloaded___1">SetIntersection</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Returns the intersection of <span class="local_symbol">set1</span> and <span class="local_symbol">set2</span>.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#SetIntersectionCopy___overloaded___1">SetIntersectionCopy</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Returns the intersection of <span class="local_symbol">set1</span> and <span class="local_symbol">set2</span>.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#SetDifferenceCopy___overloaded___1">SetDifferenceCopy</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Returns <span class="local_symbol">set1</span> \ <span class="local_symbol">set2</span>.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#SetSymmetricDifferenceCopy___overloaded___1">SetSymmetricDifferenceCopy</a>
</p>
</td>
<td width="15%">
<p>
function
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Returns the symmetric difference of <span class="local_symbol">set1</span> and <span class="local_symbol">set2</span>.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#ForEach">ForEach</a>
</p>
</td>
<td width="15%">
<p>
procedure
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Applies funct to every item from [start,finish).
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#Generate">Generate</a>
</p>
</td>
<td width="15%">
<p>
procedure
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Generates new items basing on the value of the old ones using funct, and assignes them in the place of the old ones.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#Copy">Copy</a>
</p>
</td>
<td width="15%">
<p>
procedure
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Copies items from [start1,finish1) to [start2,...) using itemCopier.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#Move">Move</a>
</p>
</td>
<td width="15%">
<p>
procedure
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Moves items from [start1,finish1) to before start2.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#Combine">Combine</a>
</p>
</td>
<td width="15%">
<p>
procedure
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 'Combines' items from two ranges using <span class="local_symbol">itemJoiner</span> and writes them to the third range.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#Sort">Sort</a>
</p>
</td>
<td width="15%">
<p>
procedure
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 A general sort algorithm.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#StableSort">StableSort</a>
</p>
</td>
<td width="15%">
<p>
procedure
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 A general stable sort algorithm.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#QuickSort">QuickSort</a>
</p>
</td>
<td width="15%">
<p>
procedure
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Implements the Quick-Sort algorithm.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#MergeSort">MergeSort</a>
</p>
</td>
<td width="15%">
<p>
procedure
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Implements the Merge-Sort algorithm.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#ShellSort">ShellSort</a>
</p>
</td>
<td width="15%">
<p>
procedure
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Implements the Shell-Sort algorithm.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#InsertionSort">InsertionSort</a>
</p>
</td>
<td width="15%">
<p>
procedure
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Implements the Insertion-Sort algorithm.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#InsertionSort___overloaded___0">InsertionSort</a>
</p>
</td>
<td width="15%">
<p>
procedure
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Implements the Insertion-Sort algorithm.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#Rotate">Rotate</a>
</p>
</td>
<td width="15%">
<p>
procedure
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Rotates the items in the range [start,finish) circularly so that the item from <span class="local_symbol">start</span> goes to newstart, start+1 to newstart+1, etc.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#Reverse">Reverse</a>
</p>
</td>
<td width="15%">
<p>
procedure
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Reverses the order of the items in the range [start,finish).
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#RandomShuffle">RandomShuffle</a>
</p>
</td>
<td width="15%">
<p>
procedure
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Moves the items around randomly, so that it is euqiprobable that any of the items will be at a given position.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#Merge">Merge</a>
</p>
</td>
<td width="15%">
<p>
procedure
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Merges two sorted ranges: [start1, finish1) and [start2, finish2).
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#MergeCopy">MergeCopy</a>
</p>
</td>
<td width="15%">
<p>
procedure
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 The same as above, but copies the items and leaves the two source ranges intact;.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#ForEach___overloaded___0">ForEach</a>
</p>
</td>
<td width="15%">
<p>
procedure
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Applies funct to every item from [start,finish).
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#Generate___overloaded___0">Generate</a>
</p>
</td>
<td width="15%">
<p>
procedure
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Generates new items basing on the value of the old ones using funct, and assignes them in the place of the old ones.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#Copy___overloaded___0">Copy</a>
</p>
</td>
<td width="15%">
<p>
procedure
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Copies items from [start1,finish1) to [start2,...) using itemCopier.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#Move___overloaded___0">Move</a>
</p>
</td>
<td width="15%">
<p>
procedure
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Moves items from [start1,finish1) to before start2.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#Combine___overloaded___0">Combine</a>
</p>
</td>
<td width="15%">
<p>
procedure
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 'Combines' items from two ranges using <span class="local_symbol">itemJoiner</span> and writes them to the third range.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#Sort___overloaded___0">Sort</a>
</p>
</td>
<td width="15%">
<p>
procedure
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 A general sort algorithm.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#StableSort___overloaded___0">StableSort</a>
</p>
</td>
<td width="15%">
<p>
procedure
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 A general stable sort algorithm.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#QuickSort___overloaded___0">QuickSort</a>
</p>
</td>
<td width="15%">
<p>
procedure
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Implements the Quick-Sort algorithm.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#MergeSort___overloaded___0">MergeSort</a>
</p>
</td>
<td width="15%">
<p>
procedure
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Implements the Merge-Sort algorithm.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#ShellSort___overloaded___0">ShellSort</a>
</p>
</td>
<td width="15%">
<p>
procedure
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Implements the Shell-Sort algorithm.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#InsertionSort___overloaded___1">InsertionSort</a>
</p>
</td>
<td width="15%">
<p>
procedure
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Implements the Insertion-Sort algorithm.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#InsertionSort___overloaded___2">InsertionSort</a>
</p>
</td>
<td width="15%">
<p>
procedure
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Implements the Insertion-Sort algorithm.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#Rotate___overloaded___0">Rotate</a>
</p>
</td>
<td width="15%">
<p>
procedure
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Rotates the items in the range [start,finish) circularly so that the item from <span class="local_symbol">start</span> goes to newstart, start+1 to newstart+1, etc.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#Reverse___overloaded___0">Reverse</a>
</p>
</td>
<td width="15%">
<p>
procedure
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Reverses the order of the items in the range [start,finish).
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#RandomShuffle___overloaded___0">RandomShuffle</a>
</p>
</td>
<td width="15%">
<p>
procedure
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Moves the items around randomly, so that it is euqiprobable that any of the items will be at a given position.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#Merge___overloaded___0">Merge</a>
</p>
</td>
<td width="15%">
<p>
procedure
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Merges two sorted ranges: [start1, finish1) and [start2, finish2).
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#MergeCopy___overloaded___0">MergeCopy</a>
</p>
</td>
<td width="15%">
<p>
procedure
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 The same as above, but copies the items and leaves the two source ranges intact;.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#ForEach___overloaded___1">ForEach</a>
</p>
</td>
<td width="15%">
<p>
procedure
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Applies funct to every item from [start,finish).
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#Generate___overloaded___1">Generate</a>
</p>
</td>
<td width="15%">
<p>
procedure
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Generates new items basing on the value of the old ones using funct, and assignes them in the place of the old ones.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#Copy___overloaded___1">Copy</a>
</p>
</td>
<td width="15%">
<p>
procedure
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Copies items from [start1,finish1) to [start2,...) using itemCopier.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#Move___overloaded___1">Move</a>
</p>
</td>
<td width="15%">
<p>
procedure
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Moves items from [start1,finish1) to before start2.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#Combine___overloaded___1">Combine</a>
</p>
</td>
<td width="15%">
<p>
procedure
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 'Combines' items from two ranges using <span class="local_symbol">itemJoiner</span> and writes them to the third range.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#Sort___overloaded___1">Sort</a>
</p>
</td>
<td width="15%">
<p>
procedure
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 A general sort algorithm.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#StableSort___overloaded___1">StableSort</a>
</p>
</td>
<td width="15%">
<p>
procedure
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 A general stable sort algorithm.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#QuickSort___overloaded___1">QuickSort</a>
</p>
</td>
<td width="15%">
<p>
procedure
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Implements the Quick-Sort algorithm.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#MergeSort___overloaded___1">MergeSort</a>
</p>
</td>
<td width="15%">
<p>
procedure
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Implements the Merge-Sort algorithm.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#ShellSort___overloaded___1">ShellSort</a>
</p>
</td>
<td width="15%">
<p>
procedure
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Implements the Shell-Sort algorithm.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#InsertionSort___overloaded___3">InsertionSort</a>
</p>
</td>
<td width="15%">
<p>
procedure
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Implements the Insertion-Sort algorithm.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#InsertionSort___overloaded___4">InsertionSort</a>
</p>
</td>
<td width="15%">
<p>
procedure
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Implements the Insertion-Sort algorithm.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#Rotate___overloaded___1">Rotate</a>
</p>
</td>
<td width="15%">
<p>
procedure
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Rotates the items in the range [start,finish) circularly so that the item from <span class="local_symbol">start</span> goes to newstart, start+1 to newstart+1, etc.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#Reverse___overloaded___1">Reverse</a>
</p>
</td>
<td width="15%">
<p>
procedure
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Reverses the order of the items in the range [start,finish).
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#RandomShuffle___overloaded___1">RandomShuffle</a>
</p>
</td>
<td width="15%">
<p>
procedure
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Moves the items around randomly, so that it is euqiprobable that any of the items will be at a given position.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#Merge___overloaded___1">Merge</a>
</p>
</td>
<td width="15%">
<p>
procedure
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 Merges two sorted ranges: [start1, finish1) and [start2, finish2).
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>
<a href="adtalgs.html#MergeCopy___overloaded___1">MergeCopy</a>
</p>
</td>
<td width="15%">
<p>
procedure
</p>
</td>
<td width="15%">
<p>
global
</p>
</td>
<td width="40%">
<p>

</p><p>
 The same as above, but copies the items and leaves the two source ranges intact;.
</p>
</td>
</tr>
<tr>
<td width="30%">
<p>

</p>
</td>
</tr>
</table>
<p>

</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

<br>

</p><p>
<a name="Find"><hr></a>

<h2>Find</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> Find(</span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TForwardIterator.html">TForwardIterator</a></span></span><span class="program_code">; aitem : </span><span class="program_code"><span class="global_symbol">ItemType</span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> comparer : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IBinaryComparer.html">IBinaryComparer</a></span></span><span class="program_code"> = </span><span class="program_code"><span class="keyword">nil</span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TForwardIterator.html">TForwardIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 347
</p><p>

<h3>Description</h3>
  Non-modifying algorithms.
</p><p>
 Non-modifying algorithms do not change anything in the ranges they are applied to. They can be used with defined-order containers.
</p><p>
 Returns the first position p from the start of [start,finish) for which p.Item = aitem, according to comparer (linear search).
</p><p>

<h3>Complexity</h3>
 Worst-case O(n).
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#Find">Find</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="Find___overloaded___0"><hr></a>

<h2>Find</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> Find(</span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TForwardIterator.html">TForwardIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> pred : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IUnaryPredicate.html">IUnaryPredicate</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TForwardIterator.html">TForwardIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 351
</p><p>

<h3>Description</h3>
 The same as above, but uses pred to test which item to return.
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#Find___overloaded___0">Find</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="Count"><hr></a>

<h2>Count</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> Count(</span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TForwardIterator.html">TForwardIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> pred : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IUnaryPredicate.html">IUnaryPredicate</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol">SizeType</span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 358
</p><p>

<h3>Description</h3>
 Returns the number of items satisfying the predicate pred.
</p><p>

<h3>Complexity</h3>
 O(n);.
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#Count">Count</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="Minimal"><hr></a>

<h2>Minimal</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> Minimal(</span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TForwardIterator.html">TForwardIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> comparer : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IBinaryComparer.html">IBinaryComparer</a></span></span><span class="program_code"> = </span><span class="program_code"><span class="keyword">nil</span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TForwardIterator.html">TForwardIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 362
</p><p>

<h3>Description</h3>
 Returns an iterator pointing to the first minimal item in the range [start,finish).
</p><p>

<h3>Complexity</h3>
 O(n).
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#Minimal">Minimal</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="Maximal"><hr></a>

<h2>Maximal</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> Maximal(</span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TForwardIterator.html">TForwardIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> comparer : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IBinaryComparer.html">IBinaryComparer</a></span></span><span class="program_code"> = </span><span class="program_code"><span class="keyword">nil</span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TForwardIterator.html">TForwardIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 366
</p><p>

<h3>Description</h3>
 Returns an iterator pointing to the first maximal item in the range [start,finish).
</p><p>

<h3>Complexity</h3>
 O(n);.
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#Maximal">Maximal</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="Equal"><hr></a>

<h2>Equal</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> Equal(</span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> start1, finish1, start2 : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TForwardIterator.html">TForwardIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> pred : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IBinaryPredicate.html">IBinaryPredicate</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol">Boolean</span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 370
</p><p>

<h3>Description</h3>
 Returns true if two ranges are item-to-item equal.
</p><p>

<h3>Complexity</h3>
 O(n);.
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#Equal">Equal</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="Mismatch"><hr></a>

<h2>Mismatch</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> Mismatch(</span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> start1, finish1, start2 : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TForwardIterator.html">TForwardIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> pred : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IBinaryPredicate.html">IBinaryPredicate</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol"><a href="adtiters.html#TForwardIteratorPair">TForwardIteratorPair</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 376
</p><p>

<h3>Description</h3>
 Returns the first pair of iterators such that Result.First is an iterator into the first range, Result.Second into the second, and First &lt;&gt; Second. If no such pair exists then Result.First = finish1.
</p><p>

<h3>Complexity</h3>
 O(n);.
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#Mismatch">Mismatch</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="LexicographicalCompare"><hr></a>

<h2>LexicographicalCompare</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> LexicographicalCompare(</span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> start1, finish1, start2, finish2 : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TForwardIterator.html">TForwardIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> comparer : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IBinaryComparer.html">IBinaryComparer</a></span></span><span class="program_code"> = </span><span class="program_code"><span class="keyword">nil</span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol">Integer</span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 381
</p><p>

<h3>Description</h3>
 Compares two ranges lexicographically. Returns Result &lt; 0 if range1 &lt; range2, Result &gt; 0 if range1 &gt; range2, and Result = 0 if range1 = range2.
</p><p>

<h3>Complexity</h3>
 O(n).
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#LexicographicalCompare">LexicographicalCompare</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="Partition"><hr></a>

<h2>Partition</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> Partition(start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TBidirectionalIterator.html">TBidirectionalIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> pred : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IUnaryPredicate.html">IUnaryPredicate</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TBidirectionalIterator.html">TBidirectionalIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 491
</p><p>

<h3>Description</h3>
 Partitions [start,finish) according to pred. Returns an iterator iter such that for each i in [start,iter) pred.Test(i.Item) is true, for each i in [iter, finish) pred.Test(i.Item) is false.
</p><p>

<h3>Complexity</h3>
 O(n).
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#Partition">Partition</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="Partition___overloaded___0"><hr></a>

<h2>Partition</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> Partition(start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TRandomAccessIterator.html">TRandomAccessIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> pred : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IUnaryPredicate.html">IUnaryPredicate</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TRandomAccessIterator.html">TRandomAccessIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 494
</p><p>

<h3>Description</h3>
 Partitions [start,finish) according to pred. Returns an iterator iter such that for each i in [start,iter) pred.Test(i.Item) is true, for each i in [iter, finish) pred.Test(i.Item) is false.
</p><p>

<h3>Complexity</h3>
 O(n).
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#Partition___overloaded___0">Partition</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="StablePartition"><hr></a>

<h2>StablePartition</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> StablePartition(start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TForwardIterator.html">TForwardIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> pred : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IUnaryPredicate.html">IUnaryPredicate</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TForwardIterator.html">TForwardIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 502
</p><p>

<h3>Description</h3>
 The same as the ordinary Partition, but stable. I.e. does not change the relative order of the elements for which the predicate returns the same value. If you don't like the O(n) memory usage use the MemoryEfficientStableSort algorithm instead.
</p><p>

<h3>Complexity</h3>
 O(n).
</p><p>

<h3>Memory usage</h3>
 O(n).
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#StablePartition">StablePartition</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="MemoryEfficientStablePartition"><hr></a>

<h2>MemoryEfficientStablePartition</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> MemoryEfficientStablePartition(start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TForwardIterator.html">TForwardIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> pred : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IUnaryPredicate.html">IUnaryPredicate</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TForwardIterator.html">TForwardIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 506
</p><p>

<h3>Description</h3>
 The smae as StablePartition, but better memory usage, though worse running time.
</p><p>

<h3>Complexity</h3>
 O(n*log(n)).
</p><p>

<h3>Memory usage</h3>
 O(1).
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#MemoryEfficientStablePartition">MemoryEfficientStablePartition</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="FindKthItem"><hr></a>

<h2>FindKthItem</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> FindKthItem(start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TRandomAccessIterator.html">TRandomAccessIterator</a></span></span><span class="program_code">; k : </span><span class="program_code"><span class="global_symbol">SizeType</span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> comparer : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IBinaryComparer.html">IBinaryComparer</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol">ItemType</span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 516
</p><p>

<h3>Description</h3>
 Returns the k-th item in the range [start,finish) according to comparer. This is the same as if you sorted the range with the comparer and chose the item at start + k - 1. E.g. if comparer orders the items from the smallest to the greatest, then the function returns the k-th smallest item. If the range is empty returns nil. The algorithm used is the Blum-Floyd-Pratt-Rivest-Tarjan algorithm.
</p><p>

<h3>Complexity</h3>
 Worst-case O(n).
</p><p>

<h3>Memory usage</h3>
 O(log(n)).
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#FindKthItem">FindKthItem</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="FindKthItemHoare"><hr></a>

<h2>FindKthItemHoare</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> FindKthItemHoare(start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TRandomAccessIterator.html">TRandomAccessIterator</a></span></span><span class="program_code">; k : </span><span class="program_code"><span class="global_symbol">SizeType</span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> comparer : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IBinaryComparer.html">IBinaryComparer</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol">ItemType</span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 520
</p><p>

<h3>Description</h3>
 Implements the Hoare's algorithm for finding the k-th element.
</p><p>

<h3>Complexity</h3>
 Average O(n), worst-case O(n^2);.
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#FindKthItemHoare">FindKthItemHoare</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="Delete"><hr></a>

<h2>Delete</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> Delete(start : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TForwardIterator.html">TForwardIterator</a></span></span><span class="program_code">; n : </span><span class="program_code"><span class="global_symbol">SizeType</span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol">SizeType</span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 534
</p><p>

<h3>Description</h3>
  Deleting algorithms.
</p><p>
 Deleting algorithms do not modify any items or their order, but may remove some from the container. Since each call of member method Delete may invalidate al iterators except for the iterator on which the method is called, these routines do not accept ranges but a start iterator and the number of items instead.
</p><p>
 Deletes at most n items starting from start (included). Stops if the end of the container is reached. Returns the number of items actually deleted. To delete a range use the member method Delete.
</p><p>

<h3>Complexity</h3>
 O(n).
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#Delete">Delete</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="DeleteIf"><hr></a>

<h2>DeleteIf</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> DeleteIf(start : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TForwardIterator.html">TForwardIterator</a></span></span><span class="program_code">; n : </span><span class="program_code"><span class="global_symbol">SizeType</span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> pred : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IUnaryPredicate.html">IUnaryPredicate</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol">SizeType</span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 537
</p><p>

<h3>Description</h3>
 Deletes all items in the range [start,start+n) for which pred returns true.
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#DeleteIf">DeleteIf</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="BinaryFind"><hr></a>

<h2>BinaryFind</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> BinaryFind(</span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TRandomAccessIterator.html">TRandomAccessIterator</a></span></span><span class="program_code">; aitem : </span><span class="program_code"><span class="global_symbol">ItemType</span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> comparer : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IBinaryComparer.html">IBinaryComparer</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TRandomAccessIterator.html">TRandomAccessIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 550
</p><p>

<h3>Description</h3>
  Sorted range algorithms.
</p><p>
 These algorithms may be used only with sorted ranges. Using them with defined-order containers either does not make sense or may be fatal in consequences.
</p><p>
 Performs a binary search. The range should be sorted according to comparer.
</p><p>

<h3>Complexity</h3>
 Worst-case O(log(n)).
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#BinaryFind">BinaryFind</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="InterpolationFind"><hr></a>

<h2>InterpolationFind</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> InterpolationFind(</span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TRandomAccessIterator.html">TRandomAccessIterator</a></span></span><span class="program_code">; aitem : </span><span class="program_code"><span class="global_symbol">ItemType</span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> diff : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-ISubtractor.html">ISubtractor</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TRandomAccessIterator.html">TRandomAccessIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 554
</p><p>

<h3>Description</h3>
 Performs an interpolation search. The range should be sorted according to diff.
</p><p>

<h3>Complexity</h3>
 Average O(loglog(n)) worst-case O(n);.
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#InterpolationFind">InterpolationFind</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="Unique"><hr></a>

<h2>Unique</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> Unique(start : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TForwardIterator.html">TForwardIterator</a></span></span><span class="program_code">; n : </span><span class="program_code"><span class="global_symbol">SizeType</span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> comparer : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IBinaryComparer.html">IBinaryComparer</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol">SizeType</span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 571
</p><p>

<h3>Description</h3>
 Deletes duplicated items from the range [start,start+n). If the end of the container is reached earlier then stops. To delete duplicates from a range call Unique(start,Distance(start,finish)). To delete all the items in the container after start inclusive, call Unique(start,-1). This might be implementation-dependent, however, since it will work only if SizeType(-1) is the larges unsigned value in SizeType. This algorithm may also be used with a TSetIterator. The requirement is that all equal items must come one after another in one consecutive sequence, but the whole range need not necessarily be sorted.
</p><p>

<h3>Returns</h3>
 The number of duplicates deleted.
</p><p>

<h3>Complexity</h3>
 O(n).
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#Unique">Unique</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="SetUnion"><hr></a>

<h2>SetUnion</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> SetUnion(set1, set2 : </span><span class="program_code"><span class="global_symbol"><a href="adtcont__-TSetAdt.html">TSetAdt</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol"><a href="adtcont__-TSetAdt.html">TSetAdt</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 601
</p><p>

<h3>Description</h3>
  Set algorithms.
</p><p>
 Set algorithms operate on whole containers, which are sets. If a routine takes several sets as arguments then all of them should store the same kind of items and use the same disposers, comparers and hashers. Otherwise the behaviour is undefined.
</p><p>
 Returns the union of <span class="local_symbol">set1</span> and <span class="local_symbol">set2</span>. <span class="local_symbol">set1</span> And <span class="local_symbol">set2</span> are left empty. The result is the same type as <span class="local_symbol">set1</span>, it is obtained by calling set1.CopySelf(nil). Result.RepeatedItems is set to true and Result contains items from both sets, so we may basically say that each item is duplicated. To have a unique union of sets call the unique function on the resulting container.
</p><p>

<h3>Complexity</h3>
 O(n);.
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#SetUnion">SetUnion</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="SetUnionCopy"><hr></a>

<h2>SetUnionCopy</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> SetUnionCopy(</span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> set1, set2 : </span><span class="program_code"><span class="global_symbol"><a href="adtcont__-TSetAdt.html">TSetAdt</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> itemCopier : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IUnaryFunctor.html">IUnaryFunctor</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol"><a href="adtcont__-TSetAdt.html">TSetAdt</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 607
</p><p>

<h3>Description</h3>
 The same as above, but copies the items and does not modify the containers. Result.RepeatedItems is set to true and Result contains items from both sets, so we may basically say that each item is duplicated. To have a unique union of sets call the unique function on the resulting container.
</p><p>

<h3>Complexity</h3>
 O(n);.
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#SetUnionCopy">SetUnionCopy</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="SetUnionCopyToArg"><hr></a>

<h2>SetUnionCopyToArg</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> SetUnionCopyToArg(set1 : </span><span class="program_code"><span class="global_symbol"><a href="adtcont__-TSetAdt.html">TSetAdt</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> set2 : </span><span class="program_code"><span class="global_symbol"><a href="adtcont__-TSetAdt.html">TSetAdt</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> itemCopier : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IUnaryFunctor.html">IUnaryFunctor</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IUnaryFunctor.html">IUnaryFunctor</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 611
</p><p>

<h3>Description</h3>
 The same as above but does not create a new set but copies the items to set1 instead..
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#SetUnionCopyToArg">SetUnionCopyToArg</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="SetIntersection"><hr></a>

<h2>SetIntersection</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> SetIntersection(set1, set2 : </span><span class="program_code"><span class="global_symbol"><a href="adtcont__-TSetAdt.html">TSetAdt</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol"><a href="adtcont__-TSetAdt.html">TSetAdt</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 623
</p><p>

<h3>Description</h3>
 Returns the intersection of <span class="local_symbol">set1</span> and <span class="local_symbol">set2</span>. After this operation <span class="local_symbol">set1</span> = <span class="local_symbol">set1</span> \ <span class="local_symbol">set2</span> and <span class="local_symbol">set2</span> = <span class="local_symbol">set2</span> \ <span class="local_symbol">set1</span>. To get a symmetric difference of two sets simply call this function on them and then pass the modified arguments to <a href="adtalgs.html#SetUnion">SetUnion</a>. The result is the same type as <span class="local_symbol">set1</span>, it is obtained by calling set1.CopySelf(nil). Result.RepeatedItems is set to true and Result contains items from both sets, so we may basically say that each item is duplicated. To have a unique intersection of sets call the Unique function on the resulting container.
</p><p>

<h3>Complexity</h3>
 O(n);.
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#SetIntersection">SetIntersection</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="SetIntersectionCopy"><hr></a>

<h2>SetIntersectionCopy</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> SetIntersectionCopy(</span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> set1, set2 : </span><span class="program_code"><span class="global_symbol"><a href="adtcont__-TSetAdt.html">TSetAdt</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> itemCopier : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IUnaryFunctor.html">IUnaryFunctor</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol"><a href="adtcont__-TSetAdt.html">TSetAdt</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 632
</p><p>

<h3>Description</h3>
 Returns the intersection of <span class="local_symbol">set1</span> and <span class="local_symbol">set2</span>. Copies the items and leaves its arguments intact. The result is the same type as <span class="local_symbol">set1</span>, it is obtained by calling set1.CopySelf(nil). Result.RepeatedItems is set to true and Result contains items from both sets, so we may basically say that each item is duplicated. To have a unique intersection of sets call the unique function on the resulting container.
</p><p>

<h3>Complexity</h3>
 O(n);.
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#SetIntersectionCopy">SetIntersectionCopy</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="SetDifferenceCopy"><hr></a>

<h2>SetDifferenceCopy</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> SetDifferenceCopy(</span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> set1, set2 : </span><span class="program_code"><span class="global_symbol"><a href="adtcont__-TSetAdt.html">TSetAdt</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> itemCopier : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IUnaryFunctor.html">IUnaryFunctor</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol"><a href="adtcont__-TSetAdt.html">TSetAdt</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 638
</p><p>

<h3>Description</h3>
 Returns <span class="local_symbol">set1</span> \ <span class="local_symbol">set2</span>. Copies the items and leaves its arguments intact. The result is the same type as <span class="local_symbol">set1</span>, it is obtained by calling set1.CopySelf(nil). If <span class="local_symbol">set1</span> contains duplicated items then the result also might contain duplicated items.
</p><p>

<h3>Complexity</h3>
 O(n);.
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#SetDifferenceCopy">SetDifferenceCopy</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="SetSymmetricDifferenceCopy"><hr></a>

<h2>SetSymmetricDifferenceCopy</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> SetSymmetricDifferenceCopy(</span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> set1, set2 : </span><span class="program_code"><span class="global_symbol"><a href="adtcont__-TSetAdt.html">TSetAdt</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> itemCopier : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IUnaryFunctor.html">IUnaryFunctor</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol"><a href="adtcont__-TSetAdt.html">TSetAdt</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 645
</p><p>

<h3>Description</h3>
 Returns the symmetric difference of <span class="local_symbol">set1</span> and <span class="local_symbol">set2</span>. Copies the items and leaves its arguments intact. The result is the same type as <span class="local_symbol">set1</span>, it is obtained by calling set1.CopySelf(nil). If any of the sets contains duplicated items then the result also might contain duplicated items.
</p><p>

<h3>Complexity</h3>
 O(n);.
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#SetSymmetricDifferenceCopy">SetSymmetricDifferenceCopy</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="Find___overloaded___1"><hr></a>

<h2>Find</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> Find(</span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TStringForwardIterator.html">TStringForwardIterator</a></span></span><span class="program_code">; aitem : </span><span class="program_code"><span class="global_symbol">String</span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> comparer : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IStringBinaryComparer.html">IStringBinaryComparer</a></span></span><span class="program_code"> = </span><span class="program_code"><span class="keyword">nil</span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TStringForwardIterator.html">TStringForwardIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 766
</p><p>

<h3>Description</h3>
  Non-modifying algorithms.
</p><p>
 Non-modifying algorithms do not change anything in the ranges they are applied to. They can be used with defined-order containers.
</p><p>
 Returns the first position p from the start of [start,finish) for which p.Item = aitem, according to comparer (linear search).
</p><p>

<h3>Complexity</h3>
 Worst-case O(n).
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#Find___overloaded___1">Find</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="Find___overloaded___2"><hr></a>

<h2>Find</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> Find(</span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TStringForwardIterator.html">TStringForwardIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> pred : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IStringUnaryPredicate.html">IStringUnaryPredicate</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TStringForwardIterator.html">TStringForwardIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 770
</p><p>

<h3>Description</h3>
 The same as above, but uses pred to test which item to return.
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#Find___overloaded___2">Find</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="Count___overloaded___0"><hr></a>

<h2>Count</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> Count(</span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TStringForwardIterator.html">TStringForwardIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> pred : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IStringUnaryPredicate.html">IStringUnaryPredicate</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol">SizeType</span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 777
</p><p>

<h3>Description</h3>
 Returns the number of items satisfying the predicate pred.
</p><p>

<h3>Complexity</h3>
 O(n);.
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#Count___overloaded___0">Count</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="Minimal___overloaded___0"><hr></a>

<h2>Minimal</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> Minimal(</span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TStringForwardIterator.html">TStringForwardIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> comparer : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IStringBinaryComparer.html">IStringBinaryComparer</a></span></span><span class="program_code"> = </span><span class="program_code"><span class="keyword">nil</span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TStringForwardIterator.html">TStringForwardIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 781
</p><p>

<h3>Description</h3>
 Returns an iterator pointing to the first minimal item in the range [start,finish).
</p><p>

<h3>Complexity</h3>
 O(n).
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#Minimal___overloaded___0">Minimal</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="Maximal___overloaded___0"><hr></a>

<h2>Maximal</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> Maximal(</span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TStringForwardIterator.html">TStringForwardIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> comparer : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IStringBinaryComparer.html">IStringBinaryComparer</a></span></span><span class="program_code"> = </span><span class="program_code"><span class="keyword">nil</span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TStringForwardIterator.html">TStringForwardIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 785
</p><p>

<h3>Description</h3>
 Returns an iterator pointing to the first maximal item in the range [start,finish).
</p><p>

<h3>Complexity</h3>
 O(n);.
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#Maximal___overloaded___0">Maximal</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="Equal___overloaded___0"><hr></a>

<h2>Equal</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> Equal(</span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> start1, finish1, start2 : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TStringForwardIterator.html">TStringForwardIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> pred : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IStringBinaryPredicate.html">IStringBinaryPredicate</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol">Boolean</span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 789
</p><p>

<h3>Description</h3>
 Returns true if two ranges are item-to-item equal.
</p><p>

<h3>Complexity</h3>
 O(n);.
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#Equal___overloaded___0">Equal</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="Mismatch___overloaded___0"><hr></a>

<h2>Mismatch</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> Mismatch(</span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> start1, finish1, start2 : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TStringForwardIterator.html">TStringForwardIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> pred : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IStringBinaryPredicate.html">IStringBinaryPredicate</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol"><a href="adtiters.html#TStringForwardIteratorPair">TStringForwardIteratorPair</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 795
</p><p>

<h3>Description</h3>
 Returns the first pair of iterators such that Result.First is an iterator into the first range, Result.Second into the second, and First &lt;&gt; Second. If no such pair exists then Result.First = finish1.
</p><p>

<h3>Complexity</h3>
 O(n);.
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#Mismatch___overloaded___0">Mismatch</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="LexicographicalCompare___overloaded___0"><hr></a>

<h2>LexicographicalCompare</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> LexicographicalCompare(</span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> start1, finish1, start2, finish2 : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TStringForwardIterator.html">TStringForwardIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> comparer : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IStringBinaryComparer.html">IStringBinaryComparer</a></span></span><span class="program_code"> = </span><span class="program_code"><span class="keyword">nil</span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol">Integer</span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 800
</p><p>

<h3>Description</h3>
 Compares two ranges lexicographically. Returns Result &lt; 0 if range1 &lt; range2, Result &gt; 0 if range1 &gt; range2, and Result = 0 if range1 = range2.
</p><p>

<h3>Complexity</h3>
 O(n).
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#LexicographicalCompare___overloaded___0">LexicographicalCompare</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="Partition___overloaded___1"><hr></a>

<h2>Partition</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> Partition(start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TStringBidirectionalIterator.html">TStringBidirectionalIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> pred : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IStringUnaryPredicate.html">IStringUnaryPredicate</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TStringBidirectionalIterator.html">TStringBidirectionalIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 910
</p><p>

<h3>Description</h3>
 Partitions [start,finish) according to pred. Returns an iterator iter such that for each i in [start,iter) pred.Test(i.Item) is true, for each i in [iter, finish) pred.Test(i.Item) is false.
</p><p>

<h3>Complexity</h3>
 O(n).
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#Partition___overloaded___1">Partition</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="Partition___overloaded___2"><hr></a>

<h2>Partition</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> Partition(start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TStringRandomAccessIterator.html">TStringRandomAccessIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> pred : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IStringUnaryPredicate.html">IStringUnaryPredicate</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TStringRandomAccessIterator.html">TStringRandomAccessIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 913
</p><p>

<h3>Description</h3>
 Partitions [start,finish) according to pred. Returns an iterator iter such that for each i in [start,iter) pred.Test(i.Item) is true, for each i in [iter, finish) pred.Test(i.Item) is false.
</p><p>

<h3>Complexity</h3>
 O(n).
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#Partition___overloaded___2">Partition</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="StablePartition___overloaded___0"><hr></a>

<h2>StablePartition</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> StablePartition(start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TStringForwardIterator.html">TStringForwardIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> pred : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IStringUnaryPredicate.html">IStringUnaryPredicate</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TStringForwardIterator.html">TStringForwardIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 921
</p><p>

<h3>Description</h3>
 The same as the ordinary Partition, but stable. I.e. does not change the relative order of the elements for which the predicate returns the same value. If you don't like the O(n) memory usage use the MemoryEfficientStableSort algorithm instead.
</p><p>

<h3>Complexity</h3>
 O(n).
</p><p>

<h3>Memory usage</h3>
 O(n).
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#StablePartition___overloaded___0">StablePartition</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="MemoryEfficientStablePartition___overloaded___0"><hr></a>

<h2>MemoryEfficientStablePartition</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> MemoryEfficientStablePartition(start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TStringForwardIterator.html">TStringForwardIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> pred : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IStringUnaryPredicate.html">IStringUnaryPredicate</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TStringForwardIterator.html">TStringForwardIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 925
</p><p>

<h3>Description</h3>
 The smae as StablePartition, but better memory usage, though worse running time.
</p><p>

<h3>Complexity</h3>
 O(n*log(n)).
</p><p>

<h3>Memory usage</h3>
 O(1).
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#MemoryEfficientStablePartition___overloaded___0">MemoryEfficientStablePartition</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="FindKthItem___overloaded___0"><hr></a>

<h2>FindKthItem</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> FindKthItem(start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TStringRandomAccessIterator.html">TStringRandomAccessIterator</a></span></span><span class="program_code">; k : </span><span class="program_code"><span class="global_symbol">SizeType</span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> comparer : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IStringBinaryComparer.html">IStringBinaryComparer</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol">String</span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 935
</p><p>

<h3>Description</h3>
 Returns the k-th item in the range [start,finish) according to comparer. This is the same as if you sorted the range with the comparer and chose the item at start + k - 1. E.g. if comparer orders the items from the smallest to the greatest, then the function returns the k-th smallest item. If the range is empty returns nil. The algorithm used is the Blum-Floyd-Pratt-Rivest-Tarjan algorithm.
</p><p>

<h3>Complexity</h3>
 Worst-case O(n).
</p><p>

<h3>Memory usage</h3>
 O(log(n)).
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#FindKthItem___overloaded___0">FindKthItem</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="FindKthItemHoare___overloaded___0"><hr></a>

<h2>FindKthItemHoare</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> FindKthItemHoare(start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TStringRandomAccessIterator.html">TStringRandomAccessIterator</a></span></span><span class="program_code">; k : </span><span class="program_code"><span class="global_symbol">SizeType</span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> comparer : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IStringBinaryComparer.html">IStringBinaryComparer</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol">String</span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 939
</p><p>

<h3>Description</h3>
 Implements the Hoare's algorithm for finding the k-th element.
</p><p>

<h3>Complexity</h3>
 Average O(n), worst-case O(n^2);.
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#FindKthItemHoare___overloaded___0">FindKthItemHoare</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="Delete___overloaded___0"><hr></a>

<h2>Delete</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> Delete(start : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TStringForwardIterator.html">TStringForwardIterator</a></span></span><span class="program_code">; n : </span><span class="program_code"><span class="global_symbol">SizeType</span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol">SizeType</span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 953
</p><p>

<h3>Description</h3>
  Deleting algorithms.
</p><p>
 Deleting algorithms do not modify any items or their order, but may remove some from the container. Since each call of member method Delete may invalidate al iterators except for the iterator on which the method is called, these routines do not accept ranges but a start iterator and the number of items instead.
</p><p>
 Deletes at most n items starting from start (included). Stops if the end of the container is reached. Returns the number of items actually deleted. To delete a range use the member method Delete.
</p><p>

<h3>Complexity</h3>
 O(n).
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#Delete___overloaded___0">Delete</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="DeleteIf___overloaded___0"><hr></a>

<h2>DeleteIf</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> DeleteIf(start : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TStringForwardIterator.html">TStringForwardIterator</a></span></span><span class="program_code">; n : </span><span class="program_code"><span class="global_symbol">SizeType</span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> pred : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IStringUnaryPredicate.html">IStringUnaryPredicate</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol">SizeType</span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 956
</p><p>

<h3>Description</h3>
 Deletes all items in the range [start,start+n) for which pred returns true.
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#DeleteIf___overloaded___0">DeleteIf</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="BinaryFind___overloaded___0"><hr></a>

<h2>BinaryFind</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> BinaryFind(</span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TStringRandomAccessIterator.html">TStringRandomAccessIterator</a></span></span><span class="program_code">; aitem : </span><span class="program_code"><span class="global_symbol">String</span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> comparer : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IStringBinaryComparer.html">IStringBinaryComparer</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TStringRandomAccessIterator.html">TStringRandomAccessIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 969
</p><p>

<h3>Description</h3>
  Sorted range algorithms.
</p><p>
 These algorithms may be used only with sorted ranges. Using them with defined-order containers either does not make sense or may be fatal in consequences.
</p><p>
 Performs a binary search. The range should be sorted according to comparer.
</p><p>

<h3>Complexity</h3>
 Worst-case O(log(n)).
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#BinaryFind___overloaded___0">BinaryFind</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="InterpolationFind___overloaded___0"><hr></a>

<h2>InterpolationFind</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> InterpolationFind(</span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TStringRandomAccessIterator.html">TStringRandomAccessIterator</a></span></span><span class="program_code">; aitem : </span><span class="program_code"><span class="global_symbol">String</span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> diff : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IStringSubtractor.html">IStringSubtractor</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TStringRandomAccessIterator.html">TStringRandomAccessIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 973
</p><p>

<h3>Description</h3>
 Performs an interpolation search. The range should be sorted according to diff.
</p><p>

<h3>Complexity</h3>
 Average O(loglog(n)) worst-case O(n);.
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#InterpolationFind___overloaded___0">InterpolationFind</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="Unique___overloaded___0"><hr></a>

<h2>Unique</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> Unique(start : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TStringForwardIterator.html">TStringForwardIterator</a></span></span><span class="program_code">; n : </span><span class="program_code"><span class="global_symbol">SizeType</span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> comparer : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IStringBinaryComparer.html">IStringBinaryComparer</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol">SizeType</span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 990
</p><p>

<h3>Description</h3>
 Deletes duplicated items from the range [start,start+n). If the end of the container is reached earlier then stops. To delete duplicates from a range call Unique(start,Distance(start,finish)). To delete all the items in the container after start inclusive, call Unique(start,-1). This might be implementation-dependent, however, since it will work only if SizeType(-1) is the larges unsigned value in SizeType. This algorithm may also be used with a TStringSetIterator. The requirement is that all equal items must come one after another in one consecutive sequence, but the whole range need not necessarily be sorted.
</p><p>

<h3>Returns</h3>
 The number of duplicates deleted.
</p><p>

<h3>Complexity</h3>
 O(n).
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#Unique___overloaded___0">Unique</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="SetUnion___overloaded___0"><hr></a>

<h2>SetUnion</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> SetUnion(set1, set2 : </span><span class="program_code"><span class="global_symbol"><a href="adtcont__-TStringSetAdt.html">TStringSetAdt</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol"><a href="adtcont__-TStringSetAdt.html">TStringSetAdt</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 1020
</p><p>

<h3>Description</h3>
  Set algorithms.
</p><p>
 Set algorithms operate on whole containers, which are sets. If a routine takes several sets as arguments then all of them should store the same kind of items and use the same disposers, comparers and hashers. Otherwise the behaviour is undefined.
</p><p>
 Returns the union of <span class="local_symbol">set1</span> and <span class="local_symbol">set2</span>. <span class="local_symbol">set1</span> And <span class="local_symbol">set2</span> are left empty. The result is the same type as <span class="local_symbol">set1</span>, it is obtained by calling set1.CopySelf(nil). Result.RepeatedItems is set to true and Result contains items from both sets, so we may basically say that each item is duplicated. To have a unique union of sets call the unique function on the resulting container.
</p><p>

<h3>Complexity</h3>
 O(n);.
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#SetUnion___overloaded___0">SetUnion</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="SetUnionCopy___overloaded___0"><hr></a>

<h2>SetUnionCopy</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> SetUnionCopy(</span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> set1, set2 : </span><span class="program_code"><span class="global_symbol"><a href="adtcont__-TStringSetAdt.html">TStringSetAdt</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> itemCopier : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IStringUnaryFunctor.html">IStringUnaryFunctor</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol"><a href="adtcont__-TStringSetAdt.html">TStringSetAdt</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 1026
</p><p>

<h3>Description</h3>
 The same as above, but copies the items and does not modify the containers. Result.RepeatedItems is set to true and Result contains items from both sets, so we may basically say that each item is duplicated. To have a unique union of sets call the unique function on the resulting container.
</p><p>

<h3>Complexity</h3>
 O(n);.
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#SetUnionCopy___overloaded___0">SetUnionCopy</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="SetUnionCopyToArg___overloaded___0"><hr></a>

<h2>SetUnionCopyToArg</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> SetUnionCopyToArg(set1 : </span><span class="program_code"><span class="global_symbol"><a href="adtcont__-TStringSetAdt.html">TStringSetAdt</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> set2 : </span><span class="program_code"><span class="global_symbol"><a href="adtcont__-TStringSetAdt.html">TStringSetAdt</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> itemCopier : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IStringUnaryFunctor.html">IStringUnaryFunctor</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IStringUnaryFunctor.html">IStringUnaryFunctor</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 1030
</p><p>

<h3>Description</h3>
 The same as above but does not create a new set but copies the items to set1 instead..
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#SetUnionCopyToArg___overloaded___0">SetUnionCopyToArg</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="SetIntersection___overloaded___0"><hr></a>

<h2>SetIntersection</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> SetIntersection(set1, set2 : </span><span class="program_code"><span class="global_symbol"><a href="adtcont__-TStringSetAdt.html">TStringSetAdt</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol"><a href="adtcont__-TStringSetAdt.html">TStringSetAdt</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 1042
</p><p>

<h3>Description</h3>
 Returns the intersection of <span class="local_symbol">set1</span> and <span class="local_symbol">set2</span>. After this operation <span class="local_symbol">set1</span> = <span class="local_symbol">set1</span> \ <span class="local_symbol">set2</span> and <span class="local_symbol">set2</span> = <span class="local_symbol">set2</span> \ <span class="local_symbol">set1</span>. To get a symmetric difference of two sets simply call this function on them and then pass the modified arguments to <a href="adtalgs.html#SetUnion">SetUnion</a>. The result is the same type as <span class="local_symbol">set1</span>, it is obtained by calling set1.CopySelf(nil). Result.RepeatedItems is set to true and Result contains items from both sets, so we may basically say that each item is duplicated. To have a unique intersection of sets call the Unique function on the resulting container.
</p><p>

<h3>Complexity</h3>
 O(n);.
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#SetIntersection___overloaded___0">SetIntersection</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="SetIntersectionCopy___overloaded___0"><hr></a>

<h2>SetIntersectionCopy</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> SetIntersectionCopy(</span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> set1, set2 : </span><span class="program_code"><span class="global_symbol"><a href="adtcont__-TStringSetAdt.html">TStringSetAdt</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> itemCopier : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IStringUnaryFunctor.html">IStringUnaryFunctor</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol"><a href="adtcont__-TStringSetAdt.html">TStringSetAdt</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 1051
</p><p>

<h3>Description</h3>
 Returns the intersection of <span class="local_symbol">set1</span> and <span class="local_symbol">set2</span>. Copies the items and leaves its arguments intact. The result is the same type as <span class="local_symbol">set1</span>, it is obtained by calling set1.CopySelf(nil). Result.RepeatedItems is set to true and Result contains items from both sets, so we may basically say that each item is duplicated. To have a unique intersection of sets call the unique function on the resulting container.
</p><p>

<h3>Complexity</h3>
 O(n);.
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#SetIntersectionCopy___overloaded___0">SetIntersectionCopy</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="SetDifferenceCopy___overloaded___0"><hr></a>

<h2>SetDifferenceCopy</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> SetDifferenceCopy(</span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> set1, set2 : </span><span class="program_code"><span class="global_symbol"><a href="adtcont__-TStringSetAdt.html">TStringSetAdt</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> itemCopier : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IStringUnaryFunctor.html">IStringUnaryFunctor</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol"><a href="adtcont__-TStringSetAdt.html">TStringSetAdt</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 1057
</p><p>

<h3>Description</h3>
 Returns <span class="local_symbol">set1</span> \ <span class="local_symbol">set2</span>. Copies the items and leaves its arguments intact. The result is the same type as <span class="local_symbol">set1</span>, it is obtained by calling set1.CopySelf(nil). If <span class="local_symbol">set1</span> contains duplicated items then the result also might contain duplicated items.
</p><p>

<h3>Complexity</h3>
 O(n);.
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#SetDifferenceCopy___overloaded___0">SetDifferenceCopy</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="SetSymmetricDifferenceCopy___overloaded___0"><hr></a>

<h2>SetSymmetricDifferenceCopy</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> SetSymmetricDifferenceCopy(</span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> set1, set2 : </span><span class="program_code"><span class="global_symbol"><a href="adtcont__-TStringSetAdt.html">TStringSetAdt</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> itemCopier : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IStringUnaryFunctor.html">IStringUnaryFunctor</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol"><a href="adtcont__-TStringSetAdt.html">TStringSetAdt</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 1064
</p><p>

<h3>Description</h3>
 Returns the symmetric difference of <span class="local_symbol">set1</span> and <span class="local_symbol">set2</span>. Copies the items and leaves its arguments intact. The result is the same type as <span class="local_symbol">set1</span>, it is obtained by calling set1.CopySelf(nil). If any of the sets contains duplicated items then the result also might contain duplicated items.
</p><p>

<h3>Complexity</h3>
 O(n);.
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#SetSymmetricDifferenceCopy___overloaded___0">SetSymmetricDifferenceCopy</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="Find___overloaded___3"><hr></a>

<h2>Find</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> Find(</span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TIntegerForwardIterator.html">TIntegerForwardIterator</a></span></span><span class="program_code">; aitem : </span><span class="program_code"><span class="global_symbol">Integer</span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> comparer : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IIntegerBinaryComparer.html">IIntegerBinaryComparer</a></span></span><span class="program_code"> = </span><span class="program_code"><span class="keyword">nil</span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TIntegerForwardIterator.html">TIntegerForwardIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 1185
</p><p>

<h3>Description</h3>
  Non-modifying algorithms.
</p><p>
 Non-modifying algorithms do not change anything in the ranges they are applied to. They can be used with defined-order containers.
</p><p>
 Returns the first position p from the start of [start,finish) for which p.Item = aitem, according to comparer (linear search).
</p><p>

<h3>Complexity</h3>
 Worst-case O(n).
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#Find___overloaded___3">Find</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="Find___overloaded___4"><hr></a>

<h2>Find</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> Find(</span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TIntegerForwardIterator.html">TIntegerForwardIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> pred : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IIntegerUnaryPredicate.html">IIntegerUnaryPredicate</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TIntegerForwardIterator.html">TIntegerForwardIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 1189
</p><p>

<h3>Description</h3>
 The same as above, but uses pred to test which item to return.
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#Find___overloaded___4">Find</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="Count___overloaded___1"><hr></a>

<h2>Count</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> Count(</span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TIntegerForwardIterator.html">TIntegerForwardIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> pred : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IIntegerUnaryPredicate.html">IIntegerUnaryPredicate</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol">SizeType</span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 1196
</p><p>

<h3>Description</h3>
 Returns the number of items satisfying the predicate pred.
</p><p>

<h3>Complexity</h3>
 O(n);.
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#Count___overloaded___1">Count</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="Minimal___overloaded___1"><hr></a>

<h2>Minimal</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> Minimal(</span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TIntegerForwardIterator.html">TIntegerForwardIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> comparer : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IIntegerBinaryComparer.html">IIntegerBinaryComparer</a></span></span><span class="program_code"> = </span><span class="program_code"><span class="keyword">nil</span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TIntegerForwardIterator.html">TIntegerForwardIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 1200
</p><p>

<h3>Description</h3>
 Returns an iterator pointing to the first minimal item in the range [start,finish).
</p><p>

<h3>Complexity</h3>
 O(n).
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#Minimal___overloaded___1">Minimal</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="Maximal___overloaded___1"><hr></a>

<h2>Maximal</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> Maximal(</span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TIntegerForwardIterator.html">TIntegerForwardIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> comparer : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IIntegerBinaryComparer.html">IIntegerBinaryComparer</a></span></span><span class="program_code"> = </span><span class="program_code"><span class="keyword">nil</span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TIntegerForwardIterator.html">TIntegerForwardIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 1204
</p><p>

<h3>Description</h3>
 Returns an iterator pointing to the first maximal item in the range [start,finish).
</p><p>

<h3>Complexity</h3>
 O(n);.
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#Maximal___overloaded___1">Maximal</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="Equal___overloaded___1"><hr></a>

<h2>Equal</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> Equal(</span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> start1, finish1, start2 : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TIntegerForwardIterator.html">TIntegerForwardIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> pred : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IIntegerBinaryPredicate.html">IIntegerBinaryPredicate</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol">Boolean</span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 1208
</p><p>

<h3>Description</h3>
 Returns true if two ranges are item-to-item equal.
</p><p>

<h3>Complexity</h3>
 O(n);.
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#Equal___overloaded___1">Equal</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="Mismatch___overloaded___1"><hr></a>

<h2>Mismatch</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> Mismatch(</span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> start1, finish1, start2 : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TIntegerForwardIterator.html">TIntegerForwardIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> pred : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IIntegerBinaryPredicate.html">IIntegerBinaryPredicate</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol"><a href="adtiters.html#TIntegerForwardIteratorPair">TIntegerForwardIteratorPair</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 1214
</p><p>

<h3>Description</h3>
 Returns the first pair of iterators such that Result.First is an iterator into the first range, Result.Second into the second, and First &lt;&gt; Second. If no such pair exists then Result.First = finish1.
</p><p>

<h3>Complexity</h3>
 O(n);.
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#Mismatch___overloaded___1">Mismatch</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="LexicographicalCompare___overloaded___1"><hr></a>

<h2>LexicographicalCompare</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> LexicographicalCompare(</span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> start1, finish1, start2, finish2 : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TIntegerForwardIterator.html">TIntegerForwardIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> comparer : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IIntegerBinaryComparer.html">IIntegerBinaryComparer</a></span></span><span class="program_code"> = </span><span class="program_code"><span class="keyword">nil</span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol">Integer</span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 1219
</p><p>

<h3>Description</h3>
 Compares two ranges lexicographically. Returns Result &lt; 0 if range1 &lt; range2, Result &gt; 0 if range1 &gt; range2, and Result = 0 if range1 = range2.
</p><p>

<h3>Complexity</h3>
 O(n).
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#LexicographicalCompare___overloaded___1">LexicographicalCompare</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="Partition___overloaded___3"><hr></a>

<h2>Partition</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> Partition(start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TIntegerBidirectionalIterator.html">TIntegerBidirectionalIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> pred : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IIntegerUnaryPredicate.html">IIntegerUnaryPredicate</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TIntegerBidirectionalIterator.html">TIntegerBidirectionalIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 1329
</p><p>

<h3>Description</h3>
 Partitions [start,finish) according to pred. Returns an iterator iter such that for each i in [start,iter) pred.Test(i.Item) is true, for each i in [iter, finish) pred.Test(i.Item) is false.
</p><p>

<h3>Complexity</h3>
 O(n).
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#Partition___overloaded___3">Partition</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="Partition___overloaded___4"><hr></a>

<h2>Partition</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> Partition(start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TIntegerRandomAccessIterator.html">TIntegerRandomAccessIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> pred : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IIntegerUnaryPredicate.html">IIntegerUnaryPredicate</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TIntegerRandomAccessIterator.html">TIntegerRandomAccessIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 1332
</p><p>

<h3>Description</h3>
 Partitions [start,finish) according to pred. Returns an iterator iter such that for each i in [start,iter) pred.Test(i.Item) is true, for each i in [iter, finish) pred.Test(i.Item) is false.
</p><p>

<h3>Complexity</h3>
 O(n).
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#Partition___overloaded___4">Partition</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="StablePartition___overloaded___1"><hr></a>

<h2>StablePartition</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> StablePartition(start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TIntegerForwardIterator.html">TIntegerForwardIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> pred : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IIntegerUnaryPredicate.html">IIntegerUnaryPredicate</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TIntegerForwardIterator.html">TIntegerForwardIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 1340
</p><p>

<h3>Description</h3>
 The same as the ordinary Partition, but stable. I.e. does not change the relative order of the elements for which the predicate returns the same value. If you don't like the O(n) memory usage use the MemoryEfficientStableSort algorithm instead.
</p><p>

<h3>Complexity</h3>
 O(n).
</p><p>

<h3>Memory usage</h3>
 O(n).
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#StablePartition___overloaded___1">StablePartition</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="MemoryEfficientStablePartition___overloaded___1"><hr></a>

<h2>MemoryEfficientStablePartition</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> MemoryEfficientStablePartition(start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TIntegerForwardIterator.html">TIntegerForwardIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> pred : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IIntegerUnaryPredicate.html">IIntegerUnaryPredicate</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TIntegerForwardIterator.html">TIntegerForwardIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 1344
</p><p>

<h3>Description</h3>
 The smae as StablePartition, but better memory usage, though worse running time.
</p><p>

<h3>Complexity</h3>
 O(n*log(n)).
</p><p>

<h3>Memory usage</h3>
 O(1).
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#MemoryEfficientStablePartition___overloaded___1">MemoryEfficientStablePartition</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="FindKthItem___overloaded___1"><hr></a>

<h2>FindKthItem</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> FindKthItem(start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TIntegerRandomAccessIterator.html">TIntegerRandomAccessIterator</a></span></span><span class="program_code">; k : </span><span class="program_code"><span class="global_symbol">SizeType</span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> comparer : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IIntegerBinaryComparer.html">IIntegerBinaryComparer</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol">Integer</span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 1354
</p><p>

<h3>Description</h3>
 Returns the k-th item in the range [start,finish) according to comparer. This is the same as if you sorted the range with the comparer and chose the item at start + k - 1. E.g. if comparer orders the items from the smallest to the greatest, then the function returns the k-th smallest item. If the range is empty returns nil. The algorithm used is the Blum-Floyd-Pratt-Rivest-Tarjan algorithm.
</p><p>

<h3>Complexity</h3>
 Worst-case O(n).
</p><p>

<h3>Memory usage</h3>
 O(log(n)).
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#FindKthItem___overloaded___1">FindKthItem</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="FindKthItemHoare___overloaded___1"><hr></a>

<h2>FindKthItemHoare</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> FindKthItemHoare(start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TIntegerRandomAccessIterator.html">TIntegerRandomAccessIterator</a></span></span><span class="program_code">; k : </span><span class="program_code"><span class="global_symbol">SizeType</span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> comparer : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IIntegerBinaryComparer.html">IIntegerBinaryComparer</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol">Integer</span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 1358
</p><p>

<h3>Description</h3>
 Implements the Hoare's algorithm for finding the k-th element.
</p><p>

<h3>Complexity</h3>
 Average O(n), worst-case O(n^2);.
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#FindKthItemHoare___overloaded___1">FindKthItemHoare</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="Delete___overloaded___1"><hr></a>

<h2>Delete</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> Delete(start : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TIntegerForwardIterator.html">TIntegerForwardIterator</a></span></span><span class="program_code">; n : </span><span class="program_code"><span class="global_symbol">SizeType</span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol">SizeType</span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 1372
</p><p>

<h3>Description</h3>
  Deleting algorithms.
</p><p>
 Deleting algorithms do not modify any items or their order, but may remove some from the container. Since each call of member method Delete may invalidate al iterators except for the iterator on which the method is called, these routines do not accept ranges but a start iterator and the number of items instead.
</p><p>
 Deletes at most n items starting from start (included). Stops if the end of the container is reached. Returns the number of items actually deleted. To delete a range use the member method Delete.
</p><p>

<h3>Complexity</h3>
 O(n).
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#Delete___overloaded___1">Delete</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="DeleteIf___overloaded___1"><hr></a>

<h2>DeleteIf</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> DeleteIf(start : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TIntegerForwardIterator.html">TIntegerForwardIterator</a></span></span><span class="program_code">; n : </span><span class="program_code"><span class="global_symbol">SizeType</span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> pred : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IIntegerUnaryPredicate.html">IIntegerUnaryPredicate</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol">SizeType</span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 1375
</p><p>

<h3>Description</h3>
 Deletes all items in the range [start,start+n) for which pred returns true.
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#DeleteIf___overloaded___1">DeleteIf</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="BinaryFind___overloaded___1"><hr></a>

<h2>BinaryFind</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> BinaryFind(</span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TIntegerRandomAccessIterator.html">TIntegerRandomAccessIterator</a></span></span><span class="program_code">; aitem : </span><span class="program_code"><span class="global_symbol">Integer</span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> comparer : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IIntegerBinaryComparer.html">IIntegerBinaryComparer</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TIntegerRandomAccessIterator.html">TIntegerRandomAccessIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 1388
</p><p>

<h3>Description</h3>
  Sorted range algorithms.
</p><p>
 These algorithms may be used only with sorted ranges. Using them with defined-order containers either does not make sense or may be fatal in consequences.
</p><p>
 Performs a binary search. The range should be sorted according to comparer.
</p><p>

<h3>Complexity</h3>
 Worst-case O(log(n)).
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#BinaryFind___overloaded___1">BinaryFind</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="InterpolationFind___overloaded___1"><hr></a>

<h2>InterpolationFind</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> InterpolationFind(</span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TIntegerRandomAccessIterator.html">TIntegerRandomAccessIterator</a></span></span><span class="program_code">; aitem : </span><span class="program_code"><span class="global_symbol">Integer</span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> diff : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IIntegerSubtractor.html">IIntegerSubtractor</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TIntegerRandomAccessIterator.html">TIntegerRandomAccessIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 1392
</p><p>

<h3>Description</h3>
 Performs an interpolation search. The range should be sorted according to diff.
</p><p>

<h3>Complexity</h3>
 Average O(loglog(n)) worst-case O(n);.
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#InterpolationFind___overloaded___1">InterpolationFind</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="Unique___overloaded___1"><hr></a>

<h2>Unique</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> Unique(start : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TIntegerForwardIterator.html">TIntegerForwardIterator</a></span></span><span class="program_code">; n : </span><span class="program_code"><span class="global_symbol">SizeType</span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> comparer : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IIntegerBinaryComparer.html">IIntegerBinaryComparer</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol">SizeType</span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 1409
</p><p>

<h3>Description</h3>
 Deletes duplicated items from the range [start,start+n). If the end of the container is reached earlier then stops. To delete duplicates from a range call Unique(start,Distance(start,finish)). To delete all the items in the container after start inclusive, call Unique(start,-1). This might be implementation-dependent, however, since it will work only if SizeType(-1) is the larges unsigned value in SizeType. This algorithm may also be used with a TIntegerSetIterator. The requirement is that all equal items must come one after another in one consecutive sequence, but the whole range need not necessarily be sorted.
</p><p>

<h3>Returns</h3>
 The number of duplicates deleted.
</p><p>

<h3>Complexity</h3>
 O(n).
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#Unique___overloaded___1">Unique</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="SetUnion___overloaded___1"><hr></a>

<h2>SetUnion</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> SetUnion(set1, set2 : </span><span class="program_code"><span class="global_symbol"><a href="adtcont__-TIntegerSetAdt.html">TIntegerSetAdt</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol"><a href="adtcont__-TIntegerSetAdt.html">TIntegerSetAdt</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 1439
</p><p>

<h3>Description</h3>
  Set algorithms.
</p><p>
 Set algorithms operate on whole containers, which are sets. If a routine takes several sets as arguments then all of them should store the same kind of items and use the same disposers, comparers and hashers. Otherwise the behaviour is undefined.
</p><p>
 Returns the union of <span class="local_symbol">set1</span> and <span class="local_symbol">set2</span>. <span class="local_symbol">set1</span> And <span class="local_symbol">set2</span> are left empty. The result is the same type as <span class="local_symbol">set1</span>, it is obtained by calling set1.CopySelf(nil). Result.RepeatedItems is set to true and Result contains items from both sets, so we may basically say that each item is duplicated. To have a unique union of sets call the unique function on the resulting container.
</p><p>

<h3>Complexity</h3>
 O(n);.
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#SetUnion___overloaded___1">SetUnion</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="SetUnionCopy___overloaded___1"><hr></a>

<h2>SetUnionCopy</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> SetUnionCopy(</span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> set1, set2 : </span><span class="program_code"><span class="global_symbol"><a href="adtcont__-TIntegerSetAdt.html">TIntegerSetAdt</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> itemCopier : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IIntegerUnaryFunctor.html">IIntegerUnaryFunctor</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol"><a href="adtcont__-TIntegerSetAdt.html">TIntegerSetAdt</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 1445
</p><p>

<h3>Description</h3>
 The same as above, but copies the items and does not modify the containers. Result.RepeatedItems is set to true and Result contains items from both sets, so we may basically say that each item is duplicated. To have a unique union of sets call the unique function on the resulting container.
</p><p>

<h3>Complexity</h3>
 O(n);.
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#SetUnionCopy___overloaded___1">SetUnionCopy</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="SetUnionCopyToArg___overloaded___1"><hr></a>

<h2>SetUnionCopyToArg</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> SetUnionCopyToArg(set1 : </span><span class="program_code"><span class="global_symbol"><a href="adtcont__-TIntegerSetAdt.html">TIntegerSetAdt</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> set2 : </span><span class="program_code"><span class="global_symbol"><a href="adtcont__-TIntegerSetAdt.html">TIntegerSetAdt</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> itemCopier : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IIntegerUnaryFunctor.html">IIntegerUnaryFunctor</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IIntegerUnaryFunctor.html">IIntegerUnaryFunctor</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 1449
</p><p>

<h3>Description</h3>
 The same as above but does not create a new set but copies the items to set1 instead..
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#SetUnionCopyToArg___overloaded___1">SetUnionCopyToArg</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="SetIntersection___overloaded___1"><hr></a>

<h2>SetIntersection</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> SetIntersection(set1, set2 : </span><span class="program_code"><span class="global_symbol"><a href="adtcont__-TIntegerSetAdt.html">TIntegerSetAdt</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol"><a href="adtcont__-TIntegerSetAdt.html">TIntegerSetAdt</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 1461
</p><p>

<h3>Description</h3>
 Returns the intersection of <span class="local_symbol">set1</span> and <span class="local_symbol">set2</span>. After this operation <span class="local_symbol">set1</span> = <span class="local_symbol">set1</span> \ <span class="local_symbol">set2</span> and <span class="local_symbol">set2</span> = <span class="local_symbol">set2</span> \ <span class="local_symbol">set1</span>. To get a symmetric difference of two sets simply call this function on them and then pass the modified arguments to <a href="adtalgs.html#SetUnion">SetUnion</a>. The result is the same type as <span class="local_symbol">set1</span>, it is obtained by calling set1.CopySelf(nil). Result.RepeatedItems is set to true and Result contains items from both sets, so we may basically say that each item is duplicated. To have a unique intersection of sets call the Unique function on the resulting container.
</p><p>

<h3>Complexity</h3>
 O(n);.
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#SetIntersection___overloaded___1">SetIntersection</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="SetIntersectionCopy___overloaded___1"><hr></a>

<h2>SetIntersectionCopy</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> SetIntersectionCopy(</span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> set1, set2 : </span><span class="program_code"><span class="global_symbol"><a href="adtcont__-TIntegerSetAdt.html">TIntegerSetAdt</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> itemCopier : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IIntegerUnaryFunctor.html">IIntegerUnaryFunctor</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol"><a href="adtcont__-TIntegerSetAdt.html">TIntegerSetAdt</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 1470
</p><p>

<h3>Description</h3>
 Returns the intersection of <span class="local_symbol">set1</span> and <span class="local_symbol">set2</span>. Copies the items and leaves its arguments intact. The result is the same type as <span class="local_symbol">set1</span>, it is obtained by calling set1.CopySelf(nil). Result.RepeatedItems is set to true and Result contains items from both sets, so we may basically say that each item is duplicated. To have a unique intersection of sets call the unique function on the resulting container.
</p><p>

<h3>Complexity</h3>
 O(n);.
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#SetIntersectionCopy___overloaded___1">SetIntersectionCopy</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="SetDifferenceCopy___overloaded___1"><hr></a>

<h2>SetDifferenceCopy</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> SetDifferenceCopy(</span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> set1, set2 : </span><span class="program_code"><span class="global_symbol"><a href="adtcont__-TIntegerSetAdt.html">TIntegerSetAdt</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> itemCopier : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IIntegerUnaryFunctor.html">IIntegerUnaryFunctor</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol"><a href="adtcont__-TIntegerSetAdt.html">TIntegerSetAdt</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 1476
</p><p>

<h3>Description</h3>
 Returns <span class="local_symbol">set1</span> \ <span class="local_symbol">set2</span>. Copies the items and leaves its arguments intact. The result is the same type as <span class="local_symbol">set1</span>, it is obtained by calling set1.CopySelf(nil). If <span class="local_symbol">set1</span> contains duplicated items then the result also might contain duplicated items.
</p><p>

<h3>Complexity</h3>
 O(n);.
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#SetDifferenceCopy___overloaded___1">SetDifferenceCopy</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="SetSymmetricDifferenceCopy___overloaded___1"><hr></a>

<h2>SetSymmetricDifferenceCopy</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">function</span></span><span class="program_code"> SetSymmetricDifferenceCopy(</span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> set1, set2 : </span><span class="program_code"><span class="global_symbol"><a href="adtcont__-TIntegerSetAdt.html">TIntegerSetAdt</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> itemCopier : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IIntegerUnaryFunctor.html">IIntegerUnaryFunctor</a></span></span><span class="program_code">) : </span><span class="program_code"><span class="global_symbol"><a href="adtcont__-TIntegerSetAdt.html">TIntegerSetAdt</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 1483
</p><p>

<h3>Description</h3>
 Returns the symmetric difference of <span class="local_symbol">set1</span> and <span class="local_symbol">set2</span>. Copies the items and leaves its arguments intact. The result is the same type as <span class="local_symbol">set1</span>, it is obtained by calling set1.CopySelf(nil). If any of the sets contains duplicated items then the result also might contain duplicated items.
</p><p>

<h3>Complexity</h3>
 O(n);.
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#SetSymmetricDifferenceCopy___overloaded___1">SetSymmetricDifferenceCopy</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="ForEach"><hr></a>

<h2>ForEach</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">procedure</span></span><span class="program_code"> ForEach(start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TForwardIterator.html">TForwardIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> funct : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IUnaryFunctor.html">IUnaryFunctor</a></span></span><span class="program_code">); </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 411
</p><p>

<h3>Description</h3>
  Modifying algorithms.
</p><p>
 Applies funct to every item from [start,finish). After applying the functor, the return value of the functor is re-assigned to where the item had originally been, but the item at that place is <em>never</em> disposed. This is suitable if you modify or just test the item in the functor and then return it. This may, however, make some items leak if you return a completely new item and do not dispose the old one in the functor. Be careful with this! If you want to generate new items basing on the value of the old ones and do not care for the old ones, then you may use the Generate algorithm. The ForEach algorithm may be modifying or non-modifying depending on whether the functor changes the items.
</p><p>

<h3>Complexity</h3>
 O(n).
</p><p>

<h3>See also</h3>
<a href="adtalgs.html#Generate">Generate</a>, <a href="adtalgs.html#Combine">Combine</a>, <a href="adtalgs.html#Copy">Copy</a>
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#ForEach">ForEach</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="Generate"><hr></a>

<h2>Generate</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">procedure</span></span><span class="program_code"> Generate(start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TForwardIterator.html">TForwardIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> funct : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IUnaryFunctor.html">IUnaryFunctor</a></span></span><span class="program_code">); </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 416
</p><p>

<h3>Description</h3>
 Generates new items basing on the value of the old ones using funct, and assignes them in the place of the old ones. The old items are all disposed!
</p><p>

<h3>Complexity</h3>
 O(n).
</p><p>

<h3>See also</h3>
<a href="adtalgs.html#ForEach">ForEach</a>, <a href="adtalgs.html#Combine">Combine</a>
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#Generate">Generate</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="Copy"><hr></a>

<h2>Copy</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">procedure</span></span><span class="program_code"> Copy(</span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> start1, finish1 : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TForwardIterator.html">TForwardIterator</a></span></span><span class="program_code">; start2 : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TOutputIterator.html">TOutputIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> itemCopier : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IUnaryFunctor.html">IUnaryFunctor</a></span></span><span class="program_code">); </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 422
</p><p>

<h3>Description</h3>
 Copies items from [start1,finish1) to [start2,...) using itemCopier. The end of the second range is not given, but it must contain at least the same number of items as the first one. The items in the second range are disposed.
</p><p>

<h3>Complexity</h3>
 O(n).
</p><p>

<h3>See also</h3>
<a href="adtalgs.html#Move">Move</a>
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#Copy">Copy</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="Move"><hr></a>

<h2>Move</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">procedure</span></span><span class="program_code"> Move(start1, finish1, start2 : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TForwardIterator.html">TForwardIterator</a></span></span><span class="program_code">); </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 429
</p><p>

<h3>Description</h3>
 Moves items from [start1,finish1) to before start2. In other words, inserts items from [start1,finish1) before start2, by calling start2.Insert. The range [start1,finish1) is left empty.
</p><p>

<h3>Complexity</h3>
 O(n).
</p><p>

<h3>See also</h3>
<a href="adtalgs.html#Copy">Copy</a>
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#Move">Move</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="Combine"><hr></a>

<h2>Combine</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">procedure</span></span><span class="program_code"> Combine(</span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> start1, finish1, start2 : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TForwardIterator.html">TForwardIterator</a></span></span><span class="program_code">; start3 : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TOutputIterator.html">TOutputIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> itemJoiner : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IBinaryFunctor.html">IBinaryFunctor</a></span></span><span class="program_code">); </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 435
</p><p>

<h3>Description</h3>
 'Combines' items from two ranges using <span class="local_symbol">itemJoiner</span> and writes them to the third range. The number of valid position after start2 must be the same as between start1 and start2. ItemJoiner should return a new item created basing on the data of its two arguments.
</p><p>

<h3>Complexity</h3>
 O(n).
</p><p>

<h3>See also</h3>
<a href="adtalgs.html#Copy">Copy</a>, <a href="adtalgs.html#ForEach">ForEach</a>, <a href="adtalgs.html#Generate">Generate</a>
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#Combine">Combine</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="Sort"><hr></a>

<h2>Sort</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">procedure</span></span><span class="program_code"> Sort(start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TRandomAccessIterator.html">TRandomAccessIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> comparer : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IBinaryComparer.html">IBinaryComparer</a></span></span><span class="program_code">); </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 449
</p><p>

<h3>Description</h3>
  Mutating algorithms.
</p><p>
 A general sort algorithm. Chooses the most suitable sorting algorithm for a given set of data (depending on its size).
</p><p>

<h3>Complexity</h3>
 Average O(n*log(n)).
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#Sort">Sort</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="StableSort"><hr></a>

<h2>StableSort</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">procedure</span></span><span class="program_code"> StableSort(start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TRandomAccessIterator.html">TRandomAccessIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> comparer : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IBinaryComparer.html">IBinaryComparer</a></span></span><span class="program_code">); </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 453
</p><p>

<h3>Description</h3>
 A general stable sort algorithm. Chooses the most suitable stable sorting algorithm for given data.
</p><p>

<h3>Complexity</h3>
 O(n*log(n)).
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#StableSort">StableSort</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="QuickSort"><hr></a>

<h2>QuickSort</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">procedure</span></span><span class="program_code"> QuickSort(start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TRandomAccessIterator.html">TRandomAccessIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> comparer : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IBinaryComparer.html">IBinaryComparer</a></span></span><span class="program_code">); </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 458
</p><p>

<h3>Description</h3>
 Implements the Quick-Sort algorithm.
</p><p>

<h3>Stable</h3>
 No.
</p><p>

<h3>Complexity</h3>
 Average O(n*log(n)), worst-case O(n^2).
</p><p>

<h3>Memory usage</h3>
 O(log(n)).
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#QuickSort">QuickSort</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="MergeSort"><hr></a>

<h2>MergeSort</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">procedure</span></span><span class="program_code"> MergeSort(start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TRandomAccessIterator.html">TRandomAccessIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> comparer : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IBinaryComparer.html">IBinaryComparer</a></span></span><span class="program_code">); </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 462
</p><p>

<h3>Description</h3>
 Implements the Merge-Sort algorithm.
</p><p>

<h3>Stable</h3>
 Yes.
</p><p>

<h3>Complexity</h3>
 O(n*log(n)).
</p><p>

<h3>Memory usage</h3>
 O(n);.
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#MergeSort">MergeSort</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="ShellSort"><hr></a>

<h2>ShellSort</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">procedure</span></span><span class="program_code"> ShellSort(start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TRandomAccessIterator.html">TRandomAccessIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> comparer : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IBinaryComparer.html">IBinaryComparer</a></span></span><span class="program_code">); </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 466
</p><p>

<h3>Description</h3>
 Implements the Shell-Sort algorithm.
</p><p>

<h3>Stable</h3>
 No.
</p><p>

<h3>Complexity</h3>
 Worst-case O(n^1.5).
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#ShellSort">ShellSort</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="InsertionSort"><hr></a>

<h2>InsertionSort</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">procedure</span></span><span class="program_code"> InsertionSort(start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TBidirectionalIterator.html">TBidirectionalIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> comparer : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IBinaryComparer.html">IBinaryComparer</a></span></span><span class="program_code">); </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 470
</p><p>

<h3>Description</h3>
 Implements the Insertion-Sort algorithm.
</p><p>

<h3>Stable</h3>
 Yes.
</p><p>

<h3>Complexity</h3>
 Worst-case O(n^2).
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#InsertionSort">InsertionSort</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="InsertionSort___overloaded___0"><hr></a>

<h2>InsertionSort</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">procedure</span></span><span class="program_code"> InsertionSort(start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TRandomAccessIterator.html">TRandomAccessIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> comparer : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IBinaryComparer.html">IBinaryComparer</a></span></span><span class="program_code">); </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 472
</p><p>

<h3>Description</h3>
 Implements the Insertion-Sort algorithm.
</p><p>

<h3>Stable</h3>
 Yes.
</p><p>

<h3>Complexity</h3>
 Worst-case O(n^2).
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#InsertionSort___overloaded___0">InsertionSort</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="Rotate"><hr></a>

<h2>Rotate</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">procedure</span></span><span class="program_code"> Rotate(start, newstart, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TForwardIterator.html">TForwardIterator</a></span></span><span class="program_code">); </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 480
</p><p>

<h3>Description</h3>
 Rotates the items in the range [start,finish) circularly so that the item from <span class="local_symbol">start</span> goes to newstart, start+1 to newstart+1, etc. Newstart must be inside the range [start,finish).
</p><p>

<h3>Complexity</h3>
 O(n).
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#Rotate">Rotate</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="Reverse"><hr></a>

<h2>Reverse</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">procedure</span></span><span class="program_code"> Reverse(start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TBidirectionalIterator.html">TBidirectionalIterator</a></span></span><span class="program_code">); </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 483
</p><p>

<h3>Description</h3>
 Reverses the order of the items in the range [start,finish).
</p><p>

<h3>Complexity</h3>
 O(n);.
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#Reverse">Reverse</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="RandomShuffle"><hr></a>

<h2>RandomShuffle</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">procedure</span></span><span class="program_code"> RandomShuffle(start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TRandomAccessIterator.html">TRandomAccessIterator</a></span></span><span class="program_code">); </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 486
</p><p>

<h3>Description</h3>
 Moves the items around randomly, so that it is euqiprobable that any of the items will be at a given position.
</p><p>

<h3>Complexity</h3>
 O(n);.
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#RandomShuffle">RandomShuffle</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="Merge"><hr></a>

<h2>Merge</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">procedure</span></span><span class="program_code"> Merge(start1, finish1, start2, finish2 : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TForwardIterator.html">TForwardIterator</a></span></span><span class="program_code">; output : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TOutputIterator.html">TOutputIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> comparer : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IBinaryComparer.html">IBinaryComparer</a></span></span><span class="program_code">); </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 580
</p><p>

<h3>Description</h3>
 Merges two sorted ranges: [start1, finish1) and [start2, finish2). The resulting range is moved to output. Items are removed from both source ranges (they become empty after executing this routine).
</p><p>

<h3>Complexity</h3>
 O(n + m).
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#Merge">Merge</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="MergeCopy"><hr></a>

<h2>MergeCopy</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">procedure</span></span><span class="program_code"> MergeCopy(</span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> start1, finish1, start2, finish2 : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TForwardIterator.html">TForwardIterator</a></span></span><span class="program_code">; output : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TOutputIterator.html">TOutputIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> comparer : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IBinaryComparer.html">IBinaryComparer</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> itemCopier : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IUnaryFunctor.html">IUnaryFunctor</a></span></span><span class="program_code">); </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 585
</p><p>

<h3>Description</h3>
 The same as above, but copies the items and leaves the two source ranges intact;.
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#MergeCopy">MergeCopy</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="ForEach___overloaded___0"><hr></a>

<h2>ForEach</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">procedure</span></span><span class="program_code"> ForEach(start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TStringForwardIterator.html">TStringForwardIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> funct : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IStringUnaryFunctor.html">IStringUnaryFunctor</a></span></span><span class="program_code">); </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 830
</p><p>

<h3>Description</h3>
  Modifying algorithms.
</p><p>
 Applies funct to every item from [start,finish). After applying the functor, the return value of the functor is re-assigned to where the item had originally been, but the item at that place is <em>never</em> disposed. This is suitable if you modify or just test the item in the functor and then return it. This may, however, make some items leak if you return a completely new item and do not dispose the old one in the functor. Be careful with this! If you want to generate new items basing on the value of the old ones and do not care for the old ones, then you may use the Generate algorithm. The ForEach algorithm may be modifying or non-modifying depending on whether the functor changes the items.
</p><p>

<h3>Complexity</h3>
 O(n).
</p><p>

<h3>See also</h3>
<a href="adtalgs.html#Generate">Generate</a>, <a href="adtalgs.html#Combine">Combine</a>, <a href="adtalgs.html#Copy">Copy</a>
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#ForEach___overloaded___0">ForEach</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="Generate___overloaded___0"><hr></a>

<h2>Generate</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">procedure</span></span><span class="program_code"> Generate(start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TStringForwardIterator.html">TStringForwardIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> funct : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IStringUnaryFunctor.html">IStringUnaryFunctor</a></span></span><span class="program_code">); </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 835
</p><p>

<h3>Description</h3>
 Generates new items basing on the value of the old ones using funct, and assignes them in the place of the old ones. The old items are all disposed!
</p><p>

<h3>Complexity</h3>
 O(n).
</p><p>

<h3>See also</h3>
<a href="adtalgs.html#ForEach">ForEach</a>, <a href="adtalgs.html#Combine">Combine</a>
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#Generate___overloaded___0">Generate</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="Copy___overloaded___0"><hr></a>

<h2>Copy</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">procedure</span></span><span class="program_code"> Copy(</span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> start1, finish1 : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TStringForwardIterator.html">TStringForwardIterator</a></span></span><span class="program_code">; start2 : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TStringOutputIterator.html">TStringOutputIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> itemCopier : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IStringUnaryFunctor.html">IStringUnaryFunctor</a></span></span><span class="program_code">); </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 841
</p><p>

<h3>Description</h3>
 Copies items from [start1,finish1) to [start2,...) using itemCopier. The end of the second range is not given, but it must contain at least the same number of items as the first one. The items in the second range are disposed.
</p><p>

<h3>Complexity</h3>
 O(n).
</p><p>

<h3>See also</h3>
<a href="adtalgs.html#Move">Move</a>
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#Copy___overloaded___0">Copy</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="Move___overloaded___0"><hr></a>

<h2>Move</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">procedure</span></span><span class="program_code"> Move(start1, finish1, start2 : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TStringForwardIterator.html">TStringForwardIterator</a></span></span><span class="program_code">); </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 848
</p><p>

<h3>Description</h3>
 Moves items from [start1,finish1) to before start2. In other words, inserts items from [start1,finish1) before start2, by calling start2.Insert. The range [start1,finish1) is left empty.
</p><p>

<h3>Complexity</h3>
 O(n).
</p><p>

<h3>See also</h3>
<a href="adtalgs.html#Copy">Copy</a>
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#Move___overloaded___0">Move</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="Combine___overloaded___0"><hr></a>

<h2>Combine</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">procedure</span></span><span class="program_code"> Combine(</span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> start1, finish1, start2 : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TStringForwardIterator.html">TStringForwardIterator</a></span></span><span class="program_code">; start3 : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TStringOutputIterator.html">TStringOutputIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> itemJoiner : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IStringBinaryFunctor.html">IStringBinaryFunctor</a></span></span><span class="program_code">); </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 854
</p><p>

<h3>Description</h3>
 'Combines' items from two ranges using <span class="local_symbol">itemJoiner</span> and writes them to the third range. The number of valid position after start2 must be the same as between start1 and start2. ItemJoiner should return a new item created basing on the data of its two arguments.
</p><p>

<h3>Complexity</h3>
 O(n).
</p><p>

<h3>See also</h3>
<a href="adtalgs.html#Copy">Copy</a>, <a href="adtalgs.html#ForEach">ForEach</a>, <a href="adtalgs.html#Generate">Generate</a>
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#Combine___overloaded___0">Combine</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="Sort___overloaded___0"><hr></a>

<h2>Sort</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">procedure</span></span><span class="program_code"> Sort(start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TStringRandomAccessIterator.html">TStringRandomAccessIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> comparer : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IStringBinaryComparer.html">IStringBinaryComparer</a></span></span><span class="program_code">); </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 868
</p><p>

<h3>Description</h3>
  Mutating algorithms.
</p><p>
 A general sort algorithm. Chooses the most suitable sorting algorithm for a given set of data (depending on its size).
</p><p>

<h3>Complexity</h3>
 Average O(n*log(n)).
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#Sort___overloaded___0">Sort</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="StableSort___overloaded___0"><hr></a>

<h2>StableSort</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">procedure</span></span><span class="program_code"> StableSort(start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TStringRandomAccessIterator.html">TStringRandomAccessIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> comparer : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IStringBinaryComparer.html">IStringBinaryComparer</a></span></span><span class="program_code">); </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 872
</p><p>

<h3>Description</h3>
 A general stable sort algorithm. Chooses the most suitable stable sorting algorithm for given data.
</p><p>

<h3>Complexity</h3>
 O(n*log(n)).
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#StableSort___overloaded___0">StableSort</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="QuickSort___overloaded___0"><hr></a>

<h2>QuickSort</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">procedure</span></span><span class="program_code"> QuickSort(start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TStringRandomAccessIterator.html">TStringRandomAccessIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> comparer : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IStringBinaryComparer.html">IStringBinaryComparer</a></span></span><span class="program_code">); </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 877
</p><p>

<h3>Description</h3>
 Implements the Quick-Sort algorithm.
</p><p>

<h3>Stable</h3>
 No.
</p><p>

<h3>Complexity</h3>
 Average O(n*log(n)), worst-case O(n^2).
</p><p>

<h3>Memory usage</h3>
 O(log(n)).
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#QuickSort___overloaded___0">QuickSort</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="MergeSort___overloaded___0"><hr></a>

<h2>MergeSort</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">procedure</span></span><span class="program_code"> MergeSort(start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TStringRandomAccessIterator.html">TStringRandomAccessIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> comparer : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IStringBinaryComparer.html">IStringBinaryComparer</a></span></span><span class="program_code">); </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 881
</p><p>

<h3>Description</h3>
 Implements the Merge-Sort algorithm.
</p><p>

<h3>Stable</h3>
 Yes.
</p><p>

<h3>Complexity</h3>
 O(n*log(n)).
</p><p>

<h3>Memory usage</h3>
 O(n);.
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#MergeSort___overloaded___0">MergeSort</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="ShellSort___overloaded___0"><hr></a>

<h2>ShellSort</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">procedure</span></span><span class="program_code"> ShellSort(start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TStringRandomAccessIterator.html">TStringRandomAccessIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> comparer : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IStringBinaryComparer.html">IStringBinaryComparer</a></span></span><span class="program_code">); </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 885
</p><p>

<h3>Description</h3>
 Implements the Shell-Sort algorithm.
</p><p>

<h3>Stable</h3>
 No.
</p><p>

<h3>Complexity</h3>
 Worst-case O(n^1.5).
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#ShellSort___overloaded___0">ShellSort</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="InsertionSort___overloaded___1"><hr></a>

<h2>InsertionSort</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">procedure</span></span><span class="program_code"> InsertionSort(start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TStringBidirectionalIterator.html">TStringBidirectionalIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> comparer : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IStringBinaryComparer.html">IStringBinaryComparer</a></span></span><span class="program_code">); </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 889
</p><p>

<h3>Description</h3>
 Implements the Insertion-Sort algorithm.
</p><p>

<h3>Stable</h3>
 Yes.
</p><p>

<h3>Complexity</h3>
 Worst-case O(n^2).
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#InsertionSort___overloaded___1">InsertionSort</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="InsertionSort___overloaded___2"><hr></a>

<h2>InsertionSort</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">procedure</span></span><span class="program_code"> InsertionSort(start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TStringRandomAccessIterator.html">TStringRandomAccessIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> comparer : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IStringBinaryComparer.html">IStringBinaryComparer</a></span></span><span class="program_code">); </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 891
</p><p>

<h3>Description</h3>
 Implements the Insertion-Sort algorithm.
</p><p>

<h3>Stable</h3>
 Yes.
</p><p>

<h3>Complexity</h3>
 Worst-case O(n^2).
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#InsertionSort___overloaded___2">InsertionSort</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="Rotate___overloaded___0"><hr></a>

<h2>Rotate</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">procedure</span></span><span class="program_code"> Rotate(start, newstart, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TStringForwardIterator.html">TStringForwardIterator</a></span></span><span class="program_code">); </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 899
</p><p>

<h3>Description</h3>
 Rotates the items in the range [start,finish) circularly so that the item from <span class="local_symbol">start</span> goes to newstart, start+1 to newstart+1, etc. Newstart must be inside the range [start,finish).
</p><p>

<h3>Complexity</h3>
 O(n).
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#Rotate___overloaded___0">Rotate</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="Reverse___overloaded___0"><hr></a>

<h2>Reverse</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">procedure</span></span><span class="program_code"> Reverse(start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TStringBidirectionalIterator.html">TStringBidirectionalIterator</a></span></span><span class="program_code">); </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 902
</p><p>

<h3>Description</h3>
 Reverses the order of the items in the range [start,finish).
</p><p>

<h3>Complexity</h3>
 O(n);.
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#Reverse___overloaded___0">Reverse</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="RandomShuffle___overloaded___0"><hr></a>

<h2>RandomShuffle</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">procedure</span></span><span class="program_code"> RandomShuffle(start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TStringRandomAccessIterator.html">TStringRandomAccessIterator</a></span></span><span class="program_code">); </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 905
</p><p>

<h3>Description</h3>
 Moves the items around randomly, so that it is euqiprobable that any of the items will be at a given position.
</p><p>

<h3>Complexity</h3>
 O(n);.
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#RandomShuffle___overloaded___0">RandomShuffle</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="Merge___overloaded___0"><hr></a>

<h2>Merge</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">procedure</span></span><span class="program_code"> Merge(start1, finish1, start2, finish2 : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TStringForwardIterator.html">TStringForwardIterator</a></span></span><span class="program_code">; output : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TStringOutputIterator.html">TStringOutputIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> comparer : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IStringBinaryComparer.html">IStringBinaryComparer</a></span></span><span class="program_code">); </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 999
</p><p>

<h3>Description</h3>
 Merges two sorted ranges: [start1, finish1) and [start2, finish2). The resulting range is moved to output. Items are removed from both source ranges (they become empty after executing this routine).
</p><p>

<h3>Complexity</h3>
 O(n + m).
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#Merge___overloaded___0">Merge</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="MergeCopy___overloaded___0"><hr></a>

<h2>MergeCopy</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">procedure</span></span><span class="program_code"> MergeCopy(</span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> start1, finish1, start2, finish2 : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TStringForwardIterator.html">TStringForwardIterator</a></span></span><span class="program_code">; output : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TStringOutputIterator.html">TStringOutputIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> comparer : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IStringBinaryComparer.html">IStringBinaryComparer</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> itemCopier : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IStringUnaryFunctor.html">IStringUnaryFunctor</a></span></span><span class="program_code">); </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 1004
</p><p>

<h3>Description</h3>
 The same as above, but copies the items and leaves the two source ranges intact;.
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#MergeCopy___overloaded___0">MergeCopy</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="ForEach___overloaded___1"><hr></a>

<h2>ForEach</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">procedure</span></span><span class="program_code"> ForEach(start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TIntegerForwardIterator.html">TIntegerForwardIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> funct : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IIntegerUnaryFunctor.html">IIntegerUnaryFunctor</a></span></span><span class="program_code">); </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 1249
</p><p>

<h3>Description</h3>
  Modifying algorithms.
</p><p>
 Applies funct to every item from [start,finish). After applying the functor, the return value of the functor is re-assigned to where the item had originally been, but the item at that place is <em>never</em> disposed. This is suitable if you modify or just test the item in the functor and then return it. This may, however, make some items leak if you return a completely new item and do not dispose the old one in the functor. Be careful with this! If you want to generate new items basing on the value of the old ones and do not care for the old ones, then you may use the Generate algorithm. The ForEach algorithm may be modifying or non-modifying depending on whether the functor changes the items.
</p><p>

<h3>Complexity</h3>
 O(n).
</p><p>

<h3>See also</h3>
<a href="adtalgs.html#Generate">Generate</a>, <a href="adtalgs.html#Combine">Combine</a>, <a href="adtalgs.html#Copy">Copy</a>
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#ForEach___overloaded___1">ForEach</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="Generate___overloaded___1"><hr></a>

<h2>Generate</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">procedure</span></span><span class="program_code"> Generate(start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TIntegerForwardIterator.html">TIntegerForwardIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> funct : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IIntegerUnaryFunctor.html">IIntegerUnaryFunctor</a></span></span><span class="program_code">); </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 1254
</p><p>

<h3>Description</h3>
 Generates new items basing on the value of the old ones using funct, and assignes them in the place of the old ones. The old items are all disposed!
</p><p>

<h3>Complexity</h3>
 O(n).
</p><p>

<h3>See also</h3>
<a href="adtalgs.html#ForEach">ForEach</a>, <a href="adtalgs.html#Combine">Combine</a>
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#Generate___overloaded___1">Generate</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="Copy___overloaded___1"><hr></a>

<h2>Copy</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">procedure</span></span><span class="program_code"> Copy(</span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> start1, finish1 : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TIntegerForwardIterator.html">TIntegerForwardIterator</a></span></span><span class="program_code">; start2 : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TIntegerOutputIterator.html">TIntegerOutputIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> itemCopier : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IIntegerUnaryFunctor.html">IIntegerUnaryFunctor</a></span></span><span class="program_code">); </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 1260
</p><p>

<h3>Description</h3>
 Copies items from [start1,finish1) to [start2,...) using itemCopier. The end of the second range is not given, but it must contain at least the same number of items as the first one. The items in the second range are disposed.
</p><p>

<h3>Complexity</h3>
 O(n).
</p><p>

<h3>See also</h3>
<a href="adtalgs.html#Move">Move</a>
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#Copy___overloaded___1">Copy</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="Move___overloaded___1"><hr></a>

<h2>Move</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">procedure</span></span><span class="program_code"> Move(start1, finish1, start2 : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TIntegerForwardIterator.html">TIntegerForwardIterator</a></span></span><span class="program_code">); </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 1267
</p><p>

<h3>Description</h3>
 Moves items from [start1,finish1) to before start2. In other words, inserts items from [start1,finish1) before start2, by calling start2.Insert. The range [start1,finish1) is left empty.
</p><p>

<h3>Complexity</h3>
 O(n).
</p><p>

<h3>See also</h3>
<a href="adtalgs.html#Copy">Copy</a>
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#Move___overloaded___1">Move</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="Combine___overloaded___1"><hr></a>

<h2>Combine</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">procedure</span></span><span class="program_code"> Combine(</span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> start1, finish1, start2 : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TIntegerForwardIterator.html">TIntegerForwardIterator</a></span></span><span class="program_code">; start3 : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TIntegerOutputIterator.html">TIntegerOutputIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> itemJoiner : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IIntegerBinaryFunctor.html">IIntegerBinaryFunctor</a></span></span><span class="program_code">); </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 1273
</p><p>

<h3>Description</h3>
 'Combines' items from two ranges using <span class="local_symbol">itemJoiner</span> and writes them to the third range. The number of valid position after start2 must be the same as between start1 and start2. ItemJoiner should return a new item created basing on the data of its two arguments.
</p><p>

<h3>Complexity</h3>
 O(n).
</p><p>

<h3>See also</h3>
<a href="adtalgs.html#Copy">Copy</a>, <a href="adtalgs.html#ForEach">ForEach</a>, <a href="adtalgs.html#Generate">Generate</a>
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#Combine___overloaded___1">Combine</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="Sort___overloaded___1"><hr></a>

<h2>Sort</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">procedure</span></span><span class="program_code"> Sort(start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TIntegerRandomAccessIterator.html">TIntegerRandomAccessIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> comparer : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IIntegerBinaryComparer.html">IIntegerBinaryComparer</a></span></span><span class="program_code">); </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 1287
</p><p>

<h3>Description</h3>
  Mutating algorithms.
</p><p>
 A general sort algorithm. Chooses the most suitable sorting algorithm for a given set of data (depending on its size).
</p><p>

<h3>Complexity</h3>
 Average O(n*log(n)).
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#Sort___overloaded___1">Sort</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="StableSort___overloaded___1"><hr></a>

<h2>StableSort</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">procedure</span></span><span class="program_code"> StableSort(start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TIntegerRandomAccessIterator.html">TIntegerRandomAccessIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> comparer : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IIntegerBinaryComparer.html">IIntegerBinaryComparer</a></span></span><span class="program_code">); </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 1291
</p><p>

<h3>Description</h3>
 A general stable sort algorithm. Chooses the most suitable stable sorting algorithm for given data.
</p><p>

<h3>Complexity</h3>
 O(n*log(n)).
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#StableSort___overloaded___1">StableSort</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="QuickSort___overloaded___1"><hr></a>

<h2>QuickSort</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">procedure</span></span><span class="program_code"> QuickSort(start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TIntegerRandomAccessIterator.html">TIntegerRandomAccessIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> comparer : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IIntegerBinaryComparer.html">IIntegerBinaryComparer</a></span></span><span class="program_code">); </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 1296
</p><p>

<h3>Description</h3>
 Implements the Quick-Sort algorithm.
</p><p>

<h3>Stable</h3>
 No.
</p><p>

<h3>Complexity</h3>
 Average O(n*log(n)), worst-case O(n^2).
</p><p>

<h3>Memory usage</h3>
 O(log(n)).
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#QuickSort___overloaded___1">QuickSort</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="MergeSort___overloaded___1"><hr></a>

<h2>MergeSort</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">procedure</span></span><span class="program_code"> MergeSort(start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TIntegerRandomAccessIterator.html">TIntegerRandomAccessIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> comparer : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IIntegerBinaryComparer.html">IIntegerBinaryComparer</a></span></span><span class="program_code">); </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 1300
</p><p>

<h3>Description</h3>
 Implements the Merge-Sort algorithm.
</p><p>

<h3>Stable</h3>
 Yes.
</p><p>

<h3>Complexity</h3>
 O(n*log(n)).
</p><p>

<h3>Memory usage</h3>
 O(n);.
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#MergeSort___overloaded___1">MergeSort</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="ShellSort___overloaded___1"><hr></a>

<h2>ShellSort</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">procedure</span></span><span class="program_code"> ShellSort(start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TIntegerRandomAccessIterator.html">TIntegerRandomAccessIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> comparer : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IIntegerBinaryComparer.html">IIntegerBinaryComparer</a></span></span><span class="program_code">); </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 1304
</p><p>

<h3>Description</h3>
 Implements the Shell-Sort algorithm.
</p><p>

<h3>Stable</h3>
 No.
</p><p>

<h3>Complexity</h3>
 Worst-case O(n^1.5).
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#ShellSort___overloaded___1">ShellSort</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="InsertionSort___overloaded___3"><hr></a>

<h2>InsertionSort</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">procedure</span></span><span class="program_code"> InsertionSort(start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TIntegerBidirectionalIterator.html">TIntegerBidirectionalIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> comparer : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IIntegerBinaryComparer.html">IIntegerBinaryComparer</a></span></span><span class="program_code">); </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 1308
</p><p>

<h3>Description</h3>
 Implements the Insertion-Sort algorithm.
</p><p>

<h3>Stable</h3>
 Yes.
</p><p>

<h3>Complexity</h3>
 Worst-case O(n^2).
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#InsertionSort___overloaded___3">InsertionSort</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="InsertionSort___overloaded___4"><hr></a>

<h2>InsertionSort</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">procedure</span></span><span class="program_code"> InsertionSort(start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TIntegerRandomAccessIterator.html">TIntegerRandomAccessIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> comparer : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IIntegerBinaryComparer.html">IIntegerBinaryComparer</a></span></span><span class="program_code">); </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 1310
</p><p>

<h3>Description</h3>
 Implements the Insertion-Sort algorithm.
</p><p>

<h3>Stable</h3>
 Yes.
</p><p>

<h3>Complexity</h3>
 Worst-case O(n^2).
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#InsertionSort___overloaded___4">InsertionSort</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="Rotate___overloaded___1"><hr></a>

<h2>Rotate</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">procedure</span></span><span class="program_code"> Rotate(start, newstart, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TIntegerForwardIterator.html">TIntegerForwardIterator</a></span></span><span class="program_code">); </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 1318
</p><p>

<h3>Description</h3>
 Rotates the items in the range [start,finish) circularly so that the item from <span class="local_symbol">start</span> goes to newstart, start+1 to newstart+1, etc. Newstart must be inside the range [start,finish).
</p><p>

<h3>Complexity</h3>
 O(n).
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#Rotate___overloaded___1">Rotate</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="Reverse___overloaded___1"><hr></a>

<h2>Reverse</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">procedure</span></span><span class="program_code"> Reverse(start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TIntegerBidirectionalIterator.html">TIntegerBidirectionalIterator</a></span></span><span class="program_code">); </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 1321
</p><p>

<h3>Description</h3>
 Reverses the order of the items in the range [start,finish).
</p><p>

<h3>Complexity</h3>
 O(n);.
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#Reverse___overloaded___1">Reverse</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="RandomShuffle___overloaded___1"><hr></a>

<h2>RandomShuffle</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">procedure</span></span><span class="program_code"> RandomShuffle(start, finish : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TIntegerRandomAccessIterator.html">TIntegerRandomAccessIterator</a></span></span><span class="program_code">); </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 1324
</p><p>

<h3>Description</h3>
 Moves the items around randomly, so that it is euqiprobable that any of the items will be at a given position.
</p><p>

<h3>Complexity</h3>
 O(n);.
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#RandomShuffle___overloaded___1">RandomShuffle</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="Merge___overloaded___1"><hr></a>

<h2>Merge</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">procedure</span></span><span class="program_code"> Merge(start1, finish1, start2, finish2 : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TIntegerForwardIterator.html">TIntegerForwardIterator</a></span></span><span class="program_code">; output : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TIntegerOutputIterator.html">TIntegerOutputIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> comparer : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IIntegerBinaryComparer.html">IIntegerBinaryComparer</a></span></span><span class="program_code">); </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 1418
</p><p>

<h3>Description</h3>
 Merges two sorted ranges: [start1, finish1) and [start2, finish2). The resulting range is moved to output. Items are removed from both source ranges (they become empty after executing this routine).
</p><p>

<h3>Complexity</h3>
 O(n + m).
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#Merge___overloaded___1">Merge</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p><p>
<a name="MergeCopy___overloaded___1"><hr></a>

<h2>MergeCopy</h2>

<h3>Declaration</h3>

<nobr>

</p><p>
<span class="program_code"><span class="keyword">procedure</span></span><span class="program_code"> MergeCopy(</span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> start1, finish1, start2, finish2 : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TIntegerForwardIterator.html">TIntegerForwardIterator</a></span></span><span class="program_code">; output : </span><span class="program_code"><span class="global_symbol"><a href="adtiters__-TIntegerOutputIterator.html">TIntegerOutputIterator</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> comparer : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IIntegerBinaryComparer.html">IIntegerBinaryComparer</a></span></span><span class="program_code">; </span><span class="program_code"><span class="keyword">const</span></span><span class="program_code"> itemCopier : </span><span class="program_code"><span class="global_symbol"><a href="adtfunct__-IIntegerUnaryFunctor.html">IIntegerUnaryFunctor</a></span></span><span class="program_code">); </span><span class="program_code"><span class="keyword">overload</span></span><span class="program_code">;</span></nobr>

<h3>Visibility</h3>
global
<h3>Source</h3>
adtalgs.pas on line 1423
</p><p>

<h3>Description</h3>
 The same as above, but copies the items and leaves the two source ranges intact;.
</p><p>

</p>
<table cols="3" border="1" width="100%">
<tr>
<td width="33%">
<p>
<a href="adtalgs.html#MergeCopy___overloaded___1">MergeCopy</a>
</p>
</td>
<td width="33%">
<p>
<a href="adtalgs.html">adtalgs</a>
</p>
</td>
</tr>
</table>
<p>

</p>
</body>
</html>
